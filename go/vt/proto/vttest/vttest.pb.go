// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: vttest.proto

package vttest

import (
	fmt "fmt"
	io "io"
	math "math"

	proto "github.com/gogo/protobuf/proto"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// Shard describes a single shard in a keyspace.
type Shard struct {
	// name has to be unique in a keyspace. For unsharded keyspaces, it
	// should be '0'. For sharded keyspace, it should be derived from
	// the keyrange, like '-80' or '40-80'.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// db_name_override is the mysql db name for this shard. Has to be
	// globally unique. If not specified, we will by default use
	// 'vt_<keyspace>_<shard>'.
	DbNameOverride       string   `protobuf:"bytes,2,opt,name=db_name_override,json=dbNameOverride,proto3" json:"db_name_override,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Shard) Reset()         { *m = Shard{} }
func (m *Shard) String() string { return proto.CompactTextString(m) }
func (*Shard) ProtoMessage()    {}
func (*Shard) Descriptor() ([]byte, []int) {
	return fileDescriptor_b9b3dc07179a1ec9, []int{0}
}
func (m *Shard) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Shard) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Shard.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Shard) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Shard.Merge(m, src)
}
func (m *Shard) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Shard) XXX_DiscardUnknown() {
	xxx_messageInfo_Shard.DiscardUnknown(m)
}

var xxx_messageInfo_Shard proto.InternalMessageInfo

func (m *Shard) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Shard) GetDbNameOverride() string {
	if m != nil {
		return m.DbNameOverride
	}
	return ""
}

// Keyspace describes a single keyspace.
type Keyspace struct {
	// name has to be unique in a VTTestTopology.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// shards inside this keyspace. Ignored if redirect is set.
	Shards []*Shard `protobuf:"bytes,2,rep,name=shards,proto3" json:"shards,omitempty"`
	// sharding_column_name for this keyspace. Used for v2 calls, but not for v3.
	ShardingColumnName string `protobuf:"bytes,3,opt,name=sharding_column_name,json=shardingColumnName,proto3" json:"sharding_column_name,omitempty"`
	// sharding_column_type for this keyspace. Used for v2 calls, but not for v3.
	ShardingColumnType string `protobuf:"bytes,4,opt,name=sharding_column_type,json=shardingColumnType,proto3" json:"sharding_column_type,omitempty"`
	// redirects all traffic to another keyspace. If set, shards is ignored.
	ServedFrom string `protobuf:"bytes,5,opt,name=served_from,json=servedFrom,proto3" json:"served_from,omitempty"`
	// number of replica tablets to instantiate. This includes the master tablet.
	ReplicaCount int32 `protobuf:"varint,6,opt,name=replica_count,json=replicaCount,proto3" json:"replica_count,omitempty"`
	// number of rdonly tablets to instantiate.
	RdonlyCount          int32    `protobuf:"varint,7,opt,name=rdonly_count,json=rdonlyCount,proto3" json:"rdonly_count,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Keyspace) Reset()         { *m = Keyspace{} }
func (m *Keyspace) String() string { return proto.CompactTextString(m) }
func (*Keyspace) ProtoMessage()    {}
func (*Keyspace) Descriptor() ([]byte, []int) {
	return fileDescriptor_b9b3dc07179a1ec9, []int{1}
}
func (m *Keyspace) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Keyspace) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Keyspace.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Keyspace) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Keyspace.Merge(m, src)
}
func (m *Keyspace) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Keyspace) XXX_DiscardUnknown() {
	xxx_messageInfo_Keyspace.DiscardUnknown(m)
}

var xxx_messageInfo_Keyspace proto.InternalMessageInfo

func (m *Keyspace) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Keyspace) GetShards() []*Shard {
	if m != nil {
		return m.Shards
	}
	return nil
}

func (m *Keyspace) GetShardingColumnName() string {
	if m != nil {
		return m.ShardingColumnName
	}
	return ""
}

func (m *Keyspace) GetShardingColumnType() string {
	if m != nil {
		return m.ShardingColumnType
	}
	return ""
}

func (m *Keyspace) GetServedFrom() string {
	if m != nil {
		return m.ServedFrom
	}
	return ""
}

func (m *Keyspace) GetReplicaCount() int32 {
	if m != nil {
		return m.ReplicaCount
	}
	return 0
}

func (m *Keyspace) GetRdonlyCount() int32 {
	if m != nil {
		return m.RdonlyCount
	}
	return 0
}

// VTTestTopology describes the keyspaces in the topology.
type VTTestTopology struct {
	// all keyspaces in the topology.
	Keyspaces []*Keyspace `protobuf:"bytes,1,rep,name=keyspaces,proto3" json:"keyspaces,omitempty"`
	// list of cells the keyspaces reside in. Vtgate is started in only the first cell.
	Cells                []string `protobuf:"bytes,2,rep,name=cells,proto3" json:"cells,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VTTestTopology) Reset()         { *m = VTTestTopology{} }
func (m *VTTestTopology) String() string { return proto.CompactTextString(m) }
func (*VTTestTopology) ProtoMessage()    {}
func (*VTTestTopology) Descriptor() ([]byte, []int) {
	return fileDescriptor_b9b3dc07179a1ec9, []int{2}
}
func (m *VTTestTopology) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VTTestTopology) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VTTestTopology.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VTTestTopology) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VTTestTopology.Merge(m, src)
}
func (m *VTTestTopology) XXX_Size() int {
	return m.ProtoSize()
}
func (m *VTTestTopology) XXX_DiscardUnknown() {
	xxx_messageInfo_VTTestTopology.DiscardUnknown(m)
}

var xxx_messageInfo_VTTestTopology proto.InternalMessageInfo

func (m *VTTestTopology) GetKeyspaces() []*Keyspace {
	if m != nil {
		return m.Keyspaces
	}
	return nil
}

func (m *VTTestTopology) GetCells() []string {
	if m != nil {
		return m.Cells
	}
	return nil
}

func init() {
	proto.RegisterType((*Shard)(nil), "vttest.Shard")
	proto.RegisterType((*Keyspace)(nil), "vttest.Keyspace")
	proto.RegisterType((*VTTestTopology)(nil), "vttest.VTTestTopology")
}

func init() { proto.RegisterFile("vttest.proto", fileDescriptor_b9b3dc07179a1ec9) }

var fileDescriptor_b9b3dc07179a1ec9 = []byte{
	// 340 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x6c, 0x51, 0x4d, 0x4e, 0xf3, 0x30,
	0x14, 0x94, 0xdb, 0x26, 0xdf, 0xd7, 0xd7, 0x1f, 0x55, 0x56, 0x17, 0x5e, 0x95, 0xd2, 0x0a, 0x29,
	0xab, 0x84, 0x9f, 0x1b, 0x50, 0xc1, 0x06, 0x09, 0xa4, 0x10, 0x75, 0xc1, 0x26, 0x4a, 0x93, 0x47,
	0x89, 0x48, 0xe2, 0xc8, 0x76, 0x23, 0xe5, 0x1a, 0x9c, 0x80, 0xe3, 0xb0, 0xe4, 0x0c, 0xe5, 0x22,
	0x28, 0x76, 0x2a, 0x36, 0xd9, 0xcd, 0x9b, 0x19, 0xbf, 0x79, 0x1a, 0xc3, 0xb8, 0x52, 0x0a, 0xa5,
	0x72, 0x4b, 0xc1, 0x15, 0xa7, 0xb6, 0x99, 0x56, 0x77, 0x60, 0x3d, 0xbf, 0x45, 0x22, 0xa1, 0x14,
	0x06, 0x45, 0x94, 0x23, 0x23, 0x4b, 0xe2, 0x0c, 0x7d, 0x8d, 0xa9, 0x03, 0xb3, 0x64, 0x17, 0x36,
	0x30, 0xe4, 0x15, 0x0a, 0x91, 0x26, 0xc8, 0x7a, 0x5a, 0x9f, 0x26, 0xbb, 0xc7, 0x28, 0xc7, 0xa7,
	0x96, 0x5d, 0x7d, 0xf4, 0xe0, 0xff, 0x03, 0xd6, 0xb2, 0x8c, 0x62, 0xec, 0x5c, 0x75, 0x01, 0xb6,
	0x6c, 0x72, 0x24, 0xeb, 0x2d, 0xfb, 0xce, 0xe8, 0x7a, 0xe2, 0xb6, 0xe7, 0xe8, 0x74, 0xbf, 0x15,
	0xe9, 0x25, 0xcc, 0x35, 0x4a, 0x8b, 0x7d, 0x18, 0xf3, 0xec, 0x90, 0x17, 0x3a, 0x9e, 0xf5, 0xf5,
	0x2a, 0x7a, 0xd2, 0x36, 0x5a, 0x6a, 0x2e, 0xe8, 0x7a, 0xa1, 0xea, 0x12, 0xd9, 0xa0, 0xeb, 0x45,
	0x50, 0x97, 0x48, 0xcf, 0x60, 0x24, 0x51, 0x54, 0x98, 0x84, 0xaf, 0x82, 0xe7, 0xcc, 0xd2, 0x46,
	0x30, 0xd4, 0xbd, 0xe0, 0x39, 0x5d, 0xc3, 0x44, 0x60, 0x99, 0xa5, 0x71, 0x14, 0xc6, 0xfc, 0x50,
	0x28, 0x66, 0x2f, 0x89, 0x63, 0xf9, 0xe3, 0x96, 0xdc, 0x34, 0x1c, 0x3d, 0x87, 0xb1, 0x48, 0x78,
	0x91, 0xd5, 0xad, 0xe7, 0x9f, 0xf6, 0x8c, 0x0c, 0xa7, 0x2d, 0xab, 0x2d, 0x4c, 0xb7, 0x41, 0x80,
	0x52, 0x05, 0xbc, 0xe4, 0x19, 0xdf, 0xd7, 0xd4, 0x85, 0xe1, 0x7b, 0xdb, 0x92, 0x64, 0x44, 0x17,
	0x31, 0x3b, 0x15, 0x71, 0xaa, 0xcf, 0xff, 0xb3, 0xd0, 0x39, 0x58, 0x31, 0x66, 0x99, 0x29, 0x6d,
	0xe8, 0x9b, 0xe1, 0xf6, 0xea, 0xeb, 0xb8, 0x20, 0xdf, 0xc7, 0x05, 0xf9, 0xfc, 0x59, 0x90, 0x97,
	0x75, 0x95, 0x2a, 0x94, 0xd2, 0x4d, 0xb9, 0x67, 0x90, 0xb7, 0xe7, 0x5e, 0xa5, 0x3c, 0xfd, 0xcf,
	0x9e, 0x59, 0xbe, 0xb3, 0xf5, 0x74, 0xf3, 0x1b, 0x00, 0x00, 0xff, 0xff, 0x69, 0xaf, 0xe3, 0x02,
	0x05, 0x02, 0x00, 0x00,
}

func (m *Shard) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Shard) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintVttest(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.DbNameOverride) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintVttest(dAtA, i, uint64(len(m.DbNameOverride)))
		i += copy(dAtA[i:], m.DbNameOverride)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Keyspace) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Keyspace) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintVttest(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Shards) > 0 {
		for _, msg := range m.Shards {
			dAtA[i] = 0x12
			i++
			i = encodeVarintVttest(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.ShardingColumnName) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintVttest(dAtA, i, uint64(len(m.ShardingColumnName)))
		i += copy(dAtA[i:], m.ShardingColumnName)
	}
	if len(m.ShardingColumnType) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintVttest(dAtA, i, uint64(len(m.ShardingColumnType)))
		i += copy(dAtA[i:], m.ShardingColumnType)
	}
	if len(m.ServedFrom) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintVttest(dAtA, i, uint64(len(m.ServedFrom)))
		i += copy(dAtA[i:], m.ServedFrom)
	}
	if m.ReplicaCount != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintVttest(dAtA, i, uint64(m.ReplicaCount))
	}
	if m.RdonlyCount != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintVttest(dAtA, i, uint64(m.RdonlyCount))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *VTTestTopology) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VTTestTopology) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Keyspaces) > 0 {
		for _, msg := range m.Keyspaces {
			dAtA[i] = 0xa
			i++
			i = encodeVarintVttest(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Cells) > 0 {
		for _, s := range m.Cells {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintVttest(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Shard) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovVttest(uint64(l))
	}
	l = len(m.DbNameOverride)
	if l > 0 {
		n += 1 + l + sovVttest(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Keyspace) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovVttest(uint64(l))
	}
	if len(m.Shards) > 0 {
		for _, e := range m.Shards {
			l = e.ProtoSize()
			n += 1 + l + sovVttest(uint64(l))
		}
	}
	l = len(m.ShardingColumnName)
	if l > 0 {
		n += 1 + l + sovVttest(uint64(l))
	}
	l = len(m.ShardingColumnType)
	if l > 0 {
		n += 1 + l + sovVttest(uint64(l))
	}
	l = len(m.ServedFrom)
	if l > 0 {
		n += 1 + l + sovVttest(uint64(l))
	}
	if m.ReplicaCount != 0 {
		n += 1 + sovVttest(uint64(m.ReplicaCount))
	}
	if m.RdonlyCount != 0 {
		n += 1 + sovVttest(uint64(m.RdonlyCount))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VTTestTopology) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Keyspaces) > 0 {
		for _, e := range m.Keyspaces {
			l = e.ProtoSize()
			n += 1 + l + sovVttest(uint64(l))
		}
	}
	if len(m.Cells) > 0 {
		for _, s := range m.Cells {
			l = len(s)
			n += 1 + l + sovVttest(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovVttest(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozVttest(x uint64) (n int) {
	return sovVttest(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Shard) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVttest
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Shard: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Shard: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVttest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVttest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVttest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DbNameOverride", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVttest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVttest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVttest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DbNameOverride = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVttest(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVttest
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVttest
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Keyspace) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVttest
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Keyspace: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Keyspace: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVttest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVttest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVttest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVttest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVttest
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVttest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Shards = append(m.Shards, &Shard{})
			if err := m.Shards[len(m.Shards)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardingColumnName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVttest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVttest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVttest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ShardingColumnName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardingColumnType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVttest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVttest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVttest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ShardingColumnType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServedFrom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVttest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVttest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVttest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServedFrom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaCount", wireType)
			}
			m.ReplicaCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVttest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplicaCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RdonlyCount", wireType)
			}
			m.RdonlyCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVttest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RdonlyCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipVttest(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVttest
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVttest
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VTTestTopology) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVttest
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VTTestTopology: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VTTestTopology: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keyspaces", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVttest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVttest
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVttest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keyspaces = append(m.Keyspaces, &Keyspace{})
			if err := m.Keyspaces[len(m.Keyspaces)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cells", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVttest
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVttest
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVttest
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cells = append(m.Cells, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVttest(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVttest
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVttest
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipVttest(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowVttest
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowVttest
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowVttest
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthVttest
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthVttest
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowVttest
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipVttest(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthVttest
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthVttest = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowVttest   = fmt.Errorf("proto: integer overflow")
)
