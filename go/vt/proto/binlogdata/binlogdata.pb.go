// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: binlogdata.proto

package binlogdata

import (
	bytes "bytes"
	fmt "fmt"
	io "io"
	math "math"
	reflect "reflect"
	strconv "strconv"
	strings "strings"

	proto "github.com/gogo/protobuf/proto"
	query "vitess.io/vitess/go/vt/proto/query"
	topodata "vitess.io/vitess/go/vt/proto/topodata"
	vtrpc "vitess.io/vitess/go/vt/proto/vtrpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// OnDDLAction lists the possible actions for DDLs.
type OnDDLAction int32

const (
	IGNORE      OnDDLAction = 0
	STOP        OnDDLAction = 1
	EXEC        OnDDLAction = 2
	EXEC_IGNORE OnDDLAction = 3
)

var OnDDLAction_name = map[int32]string{
	0: "IGNORE",
	1: "STOP",
	2: "EXEC",
	3: "EXEC_IGNORE",
}

var OnDDLAction_value = map[string]int32{
	"IGNORE":      0,
	"STOP":        1,
	"EXEC":        2,
	"EXEC_IGNORE": 3,
}

func (OnDDLAction) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_5fd02bcb2e350dad, []int{0}
}

// VEventType enumerates the event types.
// This list is comprehensive. Many of these types
// will not be encountered in RBR mode.
type VEventType int32

const (
	UNKNOWN   VEventType = 0
	GTID      VEventType = 1
	BEGIN     VEventType = 2
	COMMIT    VEventType = 3
	ROLLBACK  VEventType = 4
	DDL       VEventType = 5
	INSERT    VEventType = 6
	REPLACE   VEventType = 7
	UPDATE    VEventType = 8
	DELETE    VEventType = 9
	SET       VEventType = 10
	OTHER     VEventType = 11
	ROW       VEventType = 12
	FIELD     VEventType = 13
	HEARTBEAT VEventType = 14
	VGTID     VEventType = 15
)

var VEventType_name = map[int32]string{
	0:  "UNKNOWN",
	1:  "GTID",
	2:  "BEGIN",
	3:  "COMMIT",
	4:  "ROLLBACK",
	5:  "DDL",
	6:  "INSERT",
	7:  "REPLACE",
	8:  "UPDATE",
	9:  "DELETE",
	10: "SET",
	11: "OTHER",
	12: "ROW",
	13: "FIELD",
	14: "HEARTBEAT",
	15: "VGTID",
}

var VEventType_value = map[string]int32{
	"UNKNOWN":   0,
	"GTID":      1,
	"BEGIN":     2,
	"COMMIT":    3,
	"ROLLBACK":  4,
	"DDL":       5,
	"INSERT":    6,
	"REPLACE":   7,
	"UPDATE":    8,
	"DELETE":    9,
	"SET":       10,
	"OTHER":     11,
	"ROW":       12,
	"FIELD":     13,
	"HEARTBEAT": 14,
	"VGTID":     15,
}

func (VEventType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_5fd02bcb2e350dad, []int{1}
}

type BinlogTransaction_Statement_Category int32

const (
	BL_UNRECOGNIZED BinlogTransaction_Statement_Category = 0
	BL_BEGIN        BinlogTransaction_Statement_Category = 1
	BL_COMMIT       BinlogTransaction_Statement_Category = 2
	BL_ROLLBACK     BinlogTransaction_Statement_Category = 3
	// BL_DML is deprecated.
	BL_DML_DEPRECATED BinlogTransaction_Statement_Category = 4
	BL_DDL            BinlogTransaction_Statement_Category = 5
	BL_SET            BinlogTransaction_Statement_Category = 6
	BL_INSERT         BinlogTransaction_Statement_Category = 7
	BL_UPDATE         BinlogTransaction_Statement_Category = 8
	BL_DELETE         BinlogTransaction_Statement_Category = 9
)

var BinlogTransaction_Statement_Category_name = map[int32]string{
	0: "BL_UNRECOGNIZED",
	1: "BL_BEGIN",
	2: "BL_COMMIT",
	3: "BL_ROLLBACK",
	4: "BL_DML_DEPRECATED",
	5: "BL_DDL",
	6: "BL_SET",
	7: "BL_INSERT",
	8: "BL_UPDATE",
	9: "BL_DELETE",
}

var BinlogTransaction_Statement_Category_value = map[string]int32{
	"BL_UNRECOGNIZED":   0,
	"BL_BEGIN":          1,
	"BL_COMMIT":         2,
	"BL_ROLLBACK":       3,
	"BL_DML_DEPRECATED": 4,
	"BL_DDL":            5,
	"BL_SET":            6,
	"BL_INSERT":         7,
	"BL_UPDATE":         8,
	"BL_DELETE":         9,
}

func (BinlogTransaction_Statement_Category) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_5fd02bcb2e350dad, []int{1, 0, 0}
}

// Charset is the per-statement charset info from a QUERY_EVENT binlog entry.
type Charset struct {
	// @@session.character_set_client
	Client int32 `protobuf:"varint,1,opt,name=client,proto3" json:"client,omitempty"`
	// @@session.collation_connection
	Conn int32 `protobuf:"varint,2,opt,name=conn,proto3" json:"conn,omitempty"`
	// @@session.collation_server
	Server int32 `protobuf:"varint,3,opt,name=server,proto3" json:"server,omitempty"`
}

func (m *Charset) Reset()      { *m = Charset{} }
func (*Charset) ProtoMessage() {}
func (*Charset) Descriptor() ([]byte, []int) {
	return fileDescriptor_5fd02bcb2e350dad, []int{0}
}
func (m *Charset) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Charset) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Charset.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Charset) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Charset.Merge(m, src)
}
func (m *Charset) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Charset) XXX_DiscardUnknown() {
	xxx_messageInfo_Charset.DiscardUnknown(m)
}

var xxx_messageInfo_Charset proto.InternalMessageInfo

func (m *Charset) GetClient() int32 {
	if m != nil {
		return m.Client
	}
	return 0
}

func (m *Charset) GetConn() int32 {
	if m != nil {
		return m.Conn
	}
	return 0
}

func (m *Charset) GetServer() int32 {
	if m != nil {
		return m.Server
	}
	return 0
}

// BinlogTransaction describes a transaction inside the binlogs.
// It is streamed by vttablet for filtered replication, used during resharding.
type BinlogTransaction struct {
	// the statements in this transaction
	Statements []*BinlogTransaction_Statement `protobuf:"bytes,1,rep,name=statements,proto3" json:"statements,omitempty"`
	// The Event Token for this event.
	EventToken *query.EventToken `protobuf:"bytes,4,opt,name=event_token,json=eventToken,proto3" json:"event_token,omitempty"`
}

func (m *BinlogTransaction) Reset()      { *m = BinlogTransaction{} }
func (*BinlogTransaction) ProtoMessage() {}
func (*BinlogTransaction) Descriptor() ([]byte, []int) {
	return fileDescriptor_5fd02bcb2e350dad, []int{1}
}
func (m *BinlogTransaction) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BinlogTransaction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BinlogTransaction.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BinlogTransaction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BinlogTransaction.Merge(m, src)
}
func (m *BinlogTransaction) XXX_Size() int {
	return m.ProtoSize()
}
func (m *BinlogTransaction) XXX_DiscardUnknown() {
	xxx_messageInfo_BinlogTransaction.DiscardUnknown(m)
}

var xxx_messageInfo_BinlogTransaction proto.InternalMessageInfo

func (m *BinlogTransaction) GetStatements() []*BinlogTransaction_Statement {
	if m != nil {
		return m.Statements
	}
	return nil
}

func (m *BinlogTransaction) GetEventToken() *query.EventToken {
	if m != nil {
		return m.EventToken
	}
	return nil
}

type BinlogTransaction_Statement struct {
	// what type of statement is this?
	Category BinlogTransaction_Statement_Category `protobuf:"varint,1,opt,name=category,proto3,enum=binlogdata.BinlogTransaction_Statement_Category" json:"category,omitempty"`
	// charset of this statement, if different from pre-negotiated default.
	Charset *Charset `protobuf:"bytes,2,opt,name=charset,proto3" json:"charset,omitempty"`
	// the sql
	Sql []byte `protobuf:"bytes,3,opt,name=sql,proto3" json:"sql,omitempty"`
}

func (m *BinlogTransaction_Statement) Reset()      { *m = BinlogTransaction_Statement{} }
func (*BinlogTransaction_Statement) ProtoMessage() {}
func (*BinlogTransaction_Statement) Descriptor() ([]byte, []int) {
	return fileDescriptor_5fd02bcb2e350dad, []int{1, 0}
}
func (m *BinlogTransaction_Statement) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BinlogTransaction_Statement) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BinlogTransaction_Statement.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BinlogTransaction_Statement) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BinlogTransaction_Statement.Merge(m, src)
}
func (m *BinlogTransaction_Statement) XXX_Size() int {
	return m.ProtoSize()
}
func (m *BinlogTransaction_Statement) XXX_DiscardUnknown() {
	xxx_messageInfo_BinlogTransaction_Statement.DiscardUnknown(m)
}

var xxx_messageInfo_BinlogTransaction_Statement proto.InternalMessageInfo

func (m *BinlogTransaction_Statement) GetCategory() BinlogTransaction_Statement_Category {
	if m != nil {
		return m.Category
	}
	return BL_UNRECOGNIZED
}

func (m *BinlogTransaction_Statement) GetCharset() *Charset {
	if m != nil {
		return m.Charset
	}
	return nil
}

func (m *BinlogTransaction_Statement) GetSql() []byte {
	if m != nil {
		return m.Sql
	}
	return nil
}

// StreamKeyRangeRequest is the payload to StreamKeyRange
type StreamKeyRangeRequest struct {
	// where to start
	Position string `protobuf:"bytes,1,opt,name=position,proto3" json:"position,omitempty"`
	// what to get
	KeyRange *topodata.KeyRange `protobuf:"bytes,2,opt,name=key_range,json=keyRange,proto3" json:"key_range,omitempty"`
	// default charset on the player side
	Charset *Charset `protobuf:"bytes,3,opt,name=charset,proto3" json:"charset,omitempty"`
}

func (m *StreamKeyRangeRequest) Reset()      { *m = StreamKeyRangeRequest{} }
func (*StreamKeyRangeRequest) ProtoMessage() {}
func (*StreamKeyRangeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_5fd02bcb2e350dad, []int{2}
}
func (m *StreamKeyRangeRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StreamKeyRangeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StreamKeyRangeRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StreamKeyRangeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StreamKeyRangeRequest.Merge(m, src)
}
func (m *StreamKeyRangeRequest) XXX_Size() int {
	return m.ProtoSize()
}
func (m *StreamKeyRangeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_StreamKeyRangeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_StreamKeyRangeRequest proto.InternalMessageInfo

func (m *StreamKeyRangeRequest) GetPosition() string {
	if m != nil {
		return m.Position
	}
	return ""
}

func (m *StreamKeyRangeRequest) GetKeyRange() *topodata.KeyRange {
	if m != nil {
		return m.KeyRange
	}
	return nil
}

func (m *StreamKeyRangeRequest) GetCharset() *Charset {
	if m != nil {
		return m.Charset
	}
	return nil
}

// StreamKeyRangeResponse is the response from StreamKeyRange
type StreamKeyRangeResponse struct {
	BinlogTransaction *BinlogTransaction `protobuf:"bytes,1,opt,name=binlog_transaction,json=binlogTransaction,proto3" json:"binlog_transaction,omitempty"`
}

func (m *StreamKeyRangeResponse) Reset()      { *m = StreamKeyRangeResponse{} }
func (*StreamKeyRangeResponse) ProtoMessage() {}
func (*StreamKeyRangeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_5fd02bcb2e350dad, []int{3}
}
func (m *StreamKeyRangeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StreamKeyRangeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StreamKeyRangeResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StreamKeyRangeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StreamKeyRangeResponse.Merge(m, src)
}
func (m *StreamKeyRangeResponse) XXX_Size() int {
	return m.ProtoSize()
}
func (m *StreamKeyRangeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_StreamKeyRangeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_StreamKeyRangeResponse proto.InternalMessageInfo

func (m *StreamKeyRangeResponse) GetBinlogTransaction() *BinlogTransaction {
	if m != nil {
		return m.BinlogTransaction
	}
	return nil
}

// StreamTablesRequest is the payload to StreamTables
type StreamTablesRequest struct {
	// where to start
	Position string `protobuf:"bytes,1,opt,name=position,proto3" json:"position,omitempty"`
	// what to get
	Tables []string `protobuf:"bytes,2,rep,name=tables,proto3" json:"tables,omitempty"`
	// default charset on the player side
	Charset *Charset `protobuf:"bytes,3,opt,name=charset,proto3" json:"charset,omitempty"`
}

func (m *StreamTablesRequest) Reset()      { *m = StreamTablesRequest{} }
func (*StreamTablesRequest) ProtoMessage() {}
func (*StreamTablesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_5fd02bcb2e350dad, []int{4}
}
func (m *StreamTablesRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StreamTablesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StreamTablesRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StreamTablesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StreamTablesRequest.Merge(m, src)
}
func (m *StreamTablesRequest) XXX_Size() int {
	return m.ProtoSize()
}
func (m *StreamTablesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_StreamTablesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_StreamTablesRequest proto.InternalMessageInfo

func (m *StreamTablesRequest) GetPosition() string {
	if m != nil {
		return m.Position
	}
	return ""
}

func (m *StreamTablesRequest) GetTables() []string {
	if m != nil {
		return m.Tables
	}
	return nil
}

func (m *StreamTablesRequest) GetCharset() *Charset {
	if m != nil {
		return m.Charset
	}
	return nil
}

// StreamTablesResponse is the response from StreamTables
type StreamTablesResponse struct {
	BinlogTransaction *BinlogTransaction `protobuf:"bytes,1,opt,name=binlog_transaction,json=binlogTransaction,proto3" json:"binlog_transaction,omitempty"`
}

func (m *StreamTablesResponse) Reset()      { *m = StreamTablesResponse{} }
func (*StreamTablesResponse) ProtoMessage() {}
func (*StreamTablesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_5fd02bcb2e350dad, []int{5}
}
func (m *StreamTablesResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StreamTablesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StreamTablesResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StreamTablesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StreamTablesResponse.Merge(m, src)
}
func (m *StreamTablesResponse) XXX_Size() int {
	return m.ProtoSize()
}
func (m *StreamTablesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_StreamTablesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_StreamTablesResponse proto.InternalMessageInfo

func (m *StreamTablesResponse) GetBinlogTransaction() *BinlogTransaction {
	if m != nil {
		return m.BinlogTransaction
	}
	return nil
}

// Rule represents one rule.
type Rule struct {
	// match can be a table name or a regular expression
	// delineated by '/' and '/'.
	Match string `protobuf:"bytes,1,opt,name=match,proto3" json:"match,omitempty"`
	// filter can be an empty string or keyrange if the match
	// is a regular expression. Otherwise, it must be a select
	// query.
	Filter string `protobuf:"bytes,2,opt,name=filter,proto3" json:"filter,omitempty"`
}

func (m *Rule) Reset()      { *m = Rule{} }
func (*Rule) ProtoMessage() {}
func (*Rule) Descriptor() ([]byte, []int) {
	return fileDescriptor_5fd02bcb2e350dad, []int{6}
}
func (m *Rule) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Rule) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Rule.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Rule) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Rule.Merge(m, src)
}
func (m *Rule) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Rule) XXX_DiscardUnknown() {
	xxx_messageInfo_Rule.DiscardUnknown(m)
}

var xxx_messageInfo_Rule proto.InternalMessageInfo

func (m *Rule) GetMatch() string {
	if m != nil {
		return m.Match
	}
	return ""
}

func (m *Rule) GetFilter() string {
	if m != nil {
		return m.Filter
	}
	return ""
}

// Filter represents a list of ordered rules. First match
// wins.
type Filter struct {
	Rules []*Rule `protobuf:"bytes,1,rep,name=rules,proto3" json:"rules,omitempty"`
}

func (m *Filter) Reset()      { *m = Filter{} }
func (*Filter) ProtoMessage() {}
func (*Filter) Descriptor() ([]byte, []int) {
	return fileDescriptor_5fd02bcb2e350dad, []int{7}
}
func (m *Filter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Filter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Filter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Filter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Filter.Merge(m, src)
}
func (m *Filter) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Filter) XXX_DiscardUnknown() {
	xxx_messageInfo_Filter.DiscardUnknown(m)
}

var xxx_messageInfo_Filter proto.InternalMessageInfo

func (m *Filter) GetRules() []*Rule {
	if m != nil {
		return m.Rules
	}
	return nil
}

// BinlogSource specifies the source  and filter parameters for
// Filtered Replication. It currently supports a keyrange
// or a list of tables.
type BinlogSource struct {
	// the source keyspace
	Keyspace string `protobuf:"bytes,1,opt,name=keyspace,proto3" json:"keyspace,omitempty"`
	// the source shard
	Shard string `protobuf:"bytes,2,opt,name=shard,proto3" json:"shard,omitempty"`
	// the source tablet type
	TabletType topodata.TabletType `protobuf:"varint,3,opt,name=tablet_type,json=tabletType,proto3,enum=topodata.TabletType" json:"tablet_type,omitempty"`
	// key_range is set if the request is for a keyrange
	KeyRange *topodata.KeyRange `protobuf:"bytes,4,opt,name=key_range,json=keyRange,proto3" json:"key_range,omitempty"`
	// tables is set if the request is for a list of tables
	Tables []string `protobuf:"bytes,5,rep,name=tables,proto3" json:"tables,omitempty"`
	// filter is set if we're using the generalized representation
	// for the filter.
	Filter *Filter `protobuf:"bytes,6,opt,name=filter,proto3" json:"filter,omitempty"`
	// on_ddl specifies the action to be taken when a DDL is encountered.
	OnDdl OnDDLAction `protobuf:"varint,7,opt,name=on_ddl,json=onDdl,proto3,enum=binlogdata.OnDDLAction" json:"on_ddl,omitempty"`
}

func (m *BinlogSource) Reset()      { *m = BinlogSource{} }
func (*BinlogSource) ProtoMessage() {}
func (*BinlogSource) Descriptor() ([]byte, []int) {
	return fileDescriptor_5fd02bcb2e350dad, []int{8}
}
func (m *BinlogSource) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BinlogSource) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BinlogSource.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BinlogSource) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BinlogSource.Merge(m, src)
}
func (m *BinlogSource) XXX_Size() int {
	return m.ProtoSize()
}
func (m *BinlogSource) XXX_DiscardUnknown() {
	xxx_messageInfo_BinlogSource.DiscardUnknown(m)
}

var xxx_messageInfo_BinlogSource proto.InternalMessageInfo

func (m *BinlogSource) GetKeyspace() string {
	if m != nil {
		return m.Keyspace
	}
	return ""
}

func (m *BinlogSource) GetShard() string {
	if m != nil {
		return m.Shard
	}
	return ""
}

func (m *BinlogSource) GetTabletType() topodata.TabletType {
	if m != nil {
		return m.TabletType
	}
	return topodata.UNKNOWN
}

func (m *BinlogSource) GetKeyRange() *topodata.KeyRange {
	if m != nil {
		return m.KeyRange
	}
	return nil
}

func (m *BinlogSource) GetTables() []string {
	if m != nil {
		return m.Tables
	}
	return nil
}

func (m *BinlogSource) GetFilter() *Filter {
	if m != nil {
		return m.Filter
	}
	return nil
}

func (m *BinlogSource) GetOnDdl() OnDDLAction {
	if m != nil {
		return m.OnDdl
	}
	return IGNORE
}

// RowChange represents one row change
type RowChange struct {
	Before *query.Row `protobuf:"bytes,1,opt,name=before,proto3" json:"before,omitempty"`
	After  *query.Row `protobuf:"bytes,2,opt,name=after,proto3" json:"after,omitempty"`
}

func (m *RowChange) Reset()      { *m = RowChange{} }
func (*RowChange) ProtoMessage() {}
func (*RowChange) Descriptor() ([]byte, []int) {
	return fileDescriptor_5fd02bcb2e350dad, []int{9}
}
func (m *RowChange) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RowChange) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RowChange.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RowChange) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RowChange.Merge(m, src)
}
func (m *RowChange) XXX_Size() int {
	return m.ProtoSize()
}
func (m *RowChange) XXX_DiscardUnknown() {
	xxx_messageInfo_RowChange.DiscardUnknown(m)
}

var xxx_messageInfo_RowChange proto.InternalMessageInfo

func (m *RowChange) GetBefore() *query.Row {
	if m != nil {
		return m.Before
	}
	return nil
}

func (m *RowChange) GetAfter() *query.Row {
	if m != nil {
		return m.After
	}
	return nil
}

// RowEvent represent row events for one table
type RowEvent struct {
	TableName  string       `protobuf:"bytes,1,opt,name=table_name,json=tableName,proto3" json:"table_name,omitempty"`
	RowChanges []*RowChange `protobuf:"bytes,2,rep,name=row_changes,json=rowChanges,proto3" json:"row_changes,omitempty"`
}

func (m *RowEvent) Reset()      { *m = RowEvent{} }
func (*RowEvent) ProtoMessage() {}
func (*RowEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_5fd02bcb2e350dad, []int{10}
}
func (m *RowEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RowEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RowEvent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RowEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RowEvent.Merge(m, src)
}
func (m *RowEvent) XXX_Size() int {
	return m.ProtoSize()
}
func (m *RowEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_RowEvent.DiscardUnknown(m)
}

var xxx_messageInfo_RowEvent proto.InternalMessageInfo

func (m *RowEvent) GetTableName() string {
	if m != nil {
		return m.TableName
	}
	return ""
}

func (m *RowEvent) GetRowChanges() []*RowChange {
	if m != nil {
		return m.RowChanges
	}
	return nil
}

type FieldEvent struct {
	TableName string         `protobuf:"bytes,1,opt,name=table_name,json=tableName,proto3" json:"table_name,omitempty"`
	Fields    []*query.Field `protobuf:"bytes,2,rep,name=fields,proto3" json:"fields,omitempty"`
}

func (m *FieldEvent) Reset()      { *m = FieldEvent{} }
func (*FieldEvent) ProtoMessage() {}
func (*FieldEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_5fd02bcb2e350dad, []int{11}
}
func (m *FieldEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FieldEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FieldEvent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FieldEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FieldEvent.Merge(m, src)
}
func (m *FieldEvent) XXX_Size() int {
	return m.ProtoSize()
}
func (m *FieldEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_FieldEvent.DiscardUnknown(m)
}

var xxx_messageInfo_FieldEvent proto.InternalMessageInfo

func (m *FieldEvent) GetTableName() string {
	if m != nil {
		return m.TableName
	}
	return ""
}

func (m *FieldEvent) GetFields() []*query.Field {
	if m != nil {
		return m.Fields
	}
	return nil
}

type ShardGtid struct {
	Keyspace string `protobuf:"bytes,1,opt,name=keyspace,proto3" json:"keyspace,omitempty"`
	Shard    string `protobuf:"bytes,2,opt,name=shard,proto3" json:"shard,omitempty"`
	Gtid     string `protobuf:"bytes,3,opt,name=gtid,proto3" json:"gtid,omitempty"`
}

func (m *ShardGtid) Reset()      { *m = ShardGtid{} }
func (*ShardGtid) ProtoMessage() {}
func (*ShardGtid) Descriptor() ([]byte, []int) {
	return fileDescriptor_5fd02bcb2e350dad, []int{12}
}
func (m *ShardGtid) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShardGtid) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShardGtid.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ShardGtid) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShardGtid.Merge(m, src)
}
func (m *ShardGtid) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ShardGtid) XXX_DiscardUnknown() {
	xxx_messageInfo_ShardGtid.DiscardUnknown(m)
}

var xxx_messageInfo_ShardGtid proto.InternalMessageInfo

func (m *ShardGtid) GetKeyspace() string {
	if m != nil {
		return m.Keyspace
	}
	return ""
}

func (m *ShardGtid) GetShard() string {
	if m != nil {
		return m.Shard
	}
	return ""
}

func (m *ShardGtid) GetGtid() string {
	if m != nil {
		return m.Gtid
	}
	return ""
}

type VGtid struct {
	ShardGtids []*ShardGtid `protobuf:"bytes,1,rep,name=shard_gtids,json=shardGtids,proto3" json:"shard_gtids,omitempty"`
}

func (m *VGtid) Reset()      { *m = VGtid{} }
func (*VGtid) ProtoMessage() {}
func (*VGtid) Descriptor() ([]byte, []int) {
	return fileDescriptor_5fd02bcb2e350dad, []int{13}
}
func (m *VGtid) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VGtid) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VGtid.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VGtid) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VGtid.Merge(m, src)
}
func (m *VGtid) XXX_Size() int {
	return m.ProtoSize()
}
func (m *VGtid) XXX_DiscardUnknown() {
	xxx_messageInfo_VGtid.DiscardUnknown(m)
}

var xxx_messageInfo_VGtid proto.InternalMessageInfo

func (m *VGtid) GetShardGtids() []*ShardGtid {
	if m != nil {
		return m.ShardGtids
	}
	return nil
}

// VEvent represents a vstream event
type VEvent struct {
	Type       VEventType  `protobuf:"varint,1,opt,name=type,proto3,enum=binlogdata.VEventType" json:"type,omitempty"`
	Timestamp  int64       `protobuf:"varint,2,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	Gtid       string      `protobuf:"bytes,3,opt,name=gtid,proto3" json:"gtid,omitempty"`
	Ddl        string      `protobuf:"bytes,4,opt,name=ddl,proto3" json:"ddl,omitempty"`
	RowEvent   *RowEvent   `protobuf:"bytes,5,opt,name=row_event,json=rowEvent,proto3" json:"row_event,omitempty"`
	FieldEvent *FieldEvent `protobuf:"bytes,6,opt,name=field_event,json=fieldEvent,proto3" json:"field_event,omitempty"`
	Vgtid      *VGtid      `protobuf:"bytes,7,opt,name=vgtid,proto3" json:"vgtid,omitempty"`
	// current_time specifies the current time to handle clock skew.
	CurrentTime int64 `protobuf:"varint,20,opt,name=current_time,json=currentTime,proto3" json:"current_time,omitempty"`
}

func (m *VEvent) Reset()      { *m = VEvent{} }
func (*VEvent) ProtoMessage() {}
func (*VEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_5fd02bcb2e350dad, []int{14}
}
func (m *VEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VEvent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VEvent.Merge(m, src)
}
func (m *VEvent) XXX_Size() int {
	return m.ProtoSize()
}
func (m *VEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_VEvent.DiscardUnknown(m)
}

var xxx_messageInfo_VEvent proto.InternalMessageInfo

func (m *VEvent) GetType() VEventType {
	if m != nil {
		return m.Type
	}
	return UNKNOWN
}

func (m *VEvent) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *VEvent) GetGtid() string {
	if m != nil {
		return m.Gtid
	}
	return ""
}

func (m *VEvent) GetDdl() string {
	if m != nil {
		return m.Ddl
	}
	return ""
}

func (m *VEvent) GetRowEvent() *RowEvent {
	if m != nil {
		return m.RowEvent
	}
	return nil
}

func (m *VEvent) GetFieldEvent() *FieldEvent {
	if m != nil {
		return m.FieldEvent
	}
	return nil
}

func (m *VEvent) GetVgtid() *VGtid {
	if m != nil {
		return m.Vgtid
	}
	return nil
}

func (m *VEvent) GetCurrentTime() int64 {
	if m != nil {
		return m.CurrentTime
	}
	return 0
}

// VStreamRequest is the payload for VStream
type VStreamRequest struct {
	EffectiveCallerId *vtrpc.CallerID       `protobuf:"bytes,1,opt,name=effective_caller_id,json=effectiveCallerId,proto3" json:"effective_caller_id,omitempty"`
	ImmediateCallerId *query.VTGateCallerID `protobuf:"bytes,2,opt,name=immediate_caller_id,json=immediateCallerId,proto3" json:"immediate_caller_id,omitempty"`
	Target            *query.Target         `protobuf:"bytes,3,opt,name=target,proto3" json:"target,omitempty"`
	Position          string                `protobuf:"bytes,4,opt,name=position,proto3" json:"position,omitempty"`
	Filter            *Filter               `protobuf:"bytes,5,opt,name=filter,proto3" json:"filter,omitempty"`
}

func (m *VStreamRequest) Reset()      { *m = VStreamRequest{} }
func (*VStreamRequest) ProtoMessage() {}
func (*VStreamRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_5fd02bcb2e350dad, []int{15}
}
func (m *VStreamRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VStreamRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VStreamRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VStreamRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VStreamRequest.Merge(m, src)
}
func (m *VStreamRequest) XXX_Size() int {
	return m.ProtoSize()
}
func (m *VStreamRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_VStreamRequest.DiscardUnknown(m)
}

var xxx_messageInfo_VStreamRequest proto.InternalMessageInfo

func (m *VStreamRequest) GetEffectiveCallerId() *vtrpc.CallerID {
	if m != nil {
		return m.EffectiveCallerId
	}
	return nil
}

func (m *VStreamRequest) GetImmediateCallerId() *query.VTGateCallerID {
	if m != nil {
		return m.ImmediateCallerId
	}
	return nil
}

func (m *VStreamRequest) GetTarget() *query.Target {
	if m != nil {
		return m.Target
	}
	return nil
}

func (m *VStreamRequest) GetPosition() string {
	if m != nil {
		return m.Position
	}
	return ""
}

func (m *VStreamRequest) GetFilter() *Filter {
	if m != nil {
		return m.Filter
	}
	return nil
}

// VStreamResponse is the response from VStream
type VStreamResponse struct {
	Events []*VEvent `protobuf:"bytes,1,rep,name=events,proto3" json:"events,omitempty"`
}

func (m *VStreamResponse) Reset()      { *m = VStreamResponse{} }
func (*VStreamResponse) ProtoMessage() {}
func (*VStreamResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_5fd02bcb2e350dad, []int{16}
}
func (m *VStreamResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VStreamResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VStreamResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VStreamResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VStreamResponse.Merge(m, src)
}
func (m *VStreamResponse) XXX_Size() int {
	return m.ProtoSize()
}
func (m *VStreamResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_VStreamResponse.DiscardUnknown(m)
}

var xxx_messageInfo_VStreamResponse proto.InternalMessageInfo

func (m *VStreamResponse) GetEvents() []*VEvent {
	if m != nil {
		return m.Events
	}
	return nil
}

// VStreamRowsRequest is the payload for VStreamRows
type VStreamRowsRequest struct {
	EffectiveCallerId *vtrpc.CallerID       `protobuf:"bytes,1,opt,name=effective_caller_id,json=effectiveCallerId,proto3" json:"effective_caller_id,omitempty"`
	ImmediateCallerId *query.VTGateCallerID `protobuf:"bytes,2,opt,name=immediate_caller_id,json=immediateCallerId,proto3" json:"immediate_caller_id,omitempty"`
	Target            *query.Target         `protobuf:"bytes,3,opt,name=target,proto3" json:"target,omitempty"`
	Query             string                `protobuf:"bytes,4,opt,name=query,proto3" json:"query,omitempty"`
	Lastpk            *query.QueryResult    `protobuf:"bytes,5,opt,name=lastpk,proto3" json:"lastpk,omitempty"`
}

func (m *VStreamRowsRequest) Reset()      { *m = VStreamRowsRequest{} }
func (*VStreamRowsRequest) ProtoMessage() {}
func (*VStreamRowsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_5fd02bcb2e350dad, []int{17}
}
func (m *VStreamRowsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VStreamRowsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VStreamRowsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VStreamRowsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VStreamRowsRequest.Merge(m, src)
}
func (m *VStreamRowsRequest) XXX_Size() int {
	return m.ProtoSize()
}
func (m *VStreamRowsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_VStreamRowsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_VStreamRowsRequest proto.InternalMessageInfo

func (m *VStreamRowsRequest) GetEffectiveCallerId() *vtrpc.CallerID {
	if m != nil {
		return m.EffectiveCallerId
	}
	return nil
}

func (m *VStreamRowsRequest) GetImmediateCallerId() *query.VTGateCallerID {
	if m != nil {
		return m.ImmediateCallerId
	}
	return nil
}

func (m *VStreamRowsRequest) GetTarget() *query.Target {
	if m != nil {
		return m.Target
	}
	return nil
}

func (m *VStreamRowsRequest) GetQuery() string {
	if m != nil {
		return m.Query
	}
	return ""
}

func (m *VStreamRowsRequest) GetLastpk() *query.QueryResult {
	if m != nil {
		return m.Lastpk
	}
	return nil
}

// VStreamRowsResponse is the response from VStreamRows
type VStreamRowsResponse struct {
	Fields   []*query.Field `protobuf:"bytes,1,rep,name=fields,proto3" json:"fields,omitempty"`
	Pkfields []*query.Field `protobuf:"bytes,2,rep,name=pkfields,proto3" json:"pkfields,omitempty"`
	Gtid     string         `protobuf:"bytes,3,opt,name=gtid,proto3" json:"gtid,omitempty"`
	Rows     []*query.Row   `protobuf:"bytes,4,rep,name=rows,proto3" json:"rows,omitempty"`
	Lastpk   *query.Row     `protobuf:"bytes,5,opt,name=lastpk,proto3" json:"lastpk,omitempty"`
}

func (m *VStreamRowsResponse) Reset()      { *m = VStreamRowsResponse{} }
func (*VStreamRowsResponse) ProtoMessage() {}
func (*VStreamRowsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_5fd02bcb2e350dad, []int{18}
}
func (m *VStreamRowsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VStreamRowsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VStreamRowsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VStreamRowsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VStreamRowsResponse.Merge(m, src)
}
func (m *VStreamRowsResponse) XXX_Size() int {
	return m.ProtoSize()
}
func (m *VStreamRowsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_VStreamRowsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_VStreamRowsResponse proto.InternalMessageInfo

func (m *VStreamRowsResponse) GetFields() []*query.Field {
	if m != nil {
		return m.Fields
	}
	return nil
}

func (m *VStreamRowsResponse) GetPkfields() []*query.Field {
	if m != nil {
		return m.Pkfields
	}
	return nil
}

func (m *VStreamRowsResponse) GetGtid() string {
	if m != nil {
		return m.Gtid
	}
	return ""
}

func (m *VStreamRowsResponse) GetRows() []*query.Row {
	if m != nil {
		return m.Rows
	}
	return nil
}

func (m *VStreamRowsResponse) GetLastpk() *query.Row {
	if m != nil {
		return m.Lastpk
	}
	return nil
}

func init() {
	proto.RegisterEnum("binlogdata.OnDDLAction", OnDDLAction_name, OnDDLAction_value)
	proto.RegisterEnum("binlogdata.VEventType", VEventType_name, VEventType_value)
	proto.RegisterEnum("binlogdata.BinlogTransaction_Statement_Category", BinlogTransaction_Statement_Category_name, BinlogTransaction_Statement_Category_value)
	proto.RegisterType((*Charset)(nil), "binlogdata.Charset")
	proto.RegisterType((*BinlogTransaction)(nil), "binlogdata.BinlogTransaction")
	proto.RegisterType((*BinlogTransaction_Statement)(nil), "binlogdata.BinlogTransaction.Statement")
	proto.RegisterType((*StreamKeyRangeRequest)(nil), "binlogdata.StreamKeyRangeRequest")
	proto.RegisterType((*StreamKeyRangeResponse)(nil), "binlogdata.StreamKeyRangeResponse")
	proto.RegisterType((*StreamTablesRequest)(nil), "binlogdata.StreamTablesRequest")
	proto.RegisterType((*StreamTablesResponse)(nil), "binlogdata.StreamTablesResponse")
	proto.RegisterType((*Rule)(nil), "binlogdata.Rule")
	proto.RegisterType((*Filter)(nil), "binlogdata.Filter")
	proto.RegisterType((*BinlogSource)(nil), "binlogdata.BinlogSource")
	proto.RegisterType((*RowChange)(nil), "binlogdata.RowChange")
	proto.RegisterType((*RowEvent)(nil), "binlogdata.RowEvent")
	proto.RegisterType((*FieldEvent)(nil), "binlogdata.FieldEvent")
	proto.RegisterType((*ShardGtid)(nil), "binlogdata.ShardGtid")
	proto.RegisterType((*VGtid)(nil), "binlogdata.VGtid")
	proto.RegisterType((*VEvent)(nil), "binlogdata.VEvent")
	proto.RegisterType((*VStreamRequest)(nil), "binlogdata.VStreamRequest")
	proto.RegisterType((*VStreamResponse)(nil), "binlogdata.VStreamResponse")
	proto.RegisterType((*VStreamRowsRequest)(nil), "binlogdata.VStreamRowsRequest")
	proto.RegisterType((*VStreamRowsResponse)(nil), "binlogdata.VStreamRowsResponse")
}

func init() { proto.RegisterFile("binlogdata.proto", fileDescriptor_5fd02bcb2e350dad) }

var fileDescriptor_5fd02bcb2e350dad = []byte{
	// 1439 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xd4, 0x57, 0x4b, 0x6f, 0x1b, 0xd5,
	0x17, 0xf7, 0xd8, 0xe3, 0xd7, 0x99, 0x34, 0x99, 0xdc, 0x3c, 0xfe, 0x56, 0xf4, 0xaf, 0x15, 0x46,
	0x40, 0xa3, 0x48, 0x38, 0xc5, 0x40, 0x59, 0x41, 0x15, 0xdb, 0xd3, 0xd4, 0xed, 0xc4, 0x4e, 0x6f,
	0xa6, 0x29, 0xaa, 0x84, 0x46, 0x13, 0xfb, 0x26, 0x19, 0x65, 0x3c, 0xe3, 0xce, 0xdc, 0x24, 0x78,
	0xc7, 0x06, 0xb1, 0x45, 0x62, 0xcb, 0x82, 0x25, 0xec, 0xf8, 0x02, 0xec, 0x10, 0x62, 0xd9, 0x65,
	0xb7, 0x4d, 0x84, 0xc4, 0xb2, 0x1f, 0x01, 0xdd, 0xc7, 0x8c, 0xed, 0xb4, 0xb4, 0x01, 0x89, 0x05,
	0x9b, 0xe8, 0xbc, 0xef, 0x39, 0xbf, 0x73, 0x7c, 0xe6, 0x04, 0xf4, 0x7d, 0x2f, 0xf0, 0xc3, 0xc3,
	0xbe, 0x4b, 0xdd, 0xda, 0x30, 0x0a, 0x69, 0x88, 0x60, 0x2c, 0x59, 0xd1, 0x4e, 0x69, 0x34, 0xec,
	0x09, 0xc5, 0x8a, 0xf6, 0xe4, 0x84, 0x44, 0x23, 0xc9, 0xcc, 0xd2, 0x70, 0x18, 0x8e, 0xbd, 0x8c,
	0x6d, 0x28, 0x36, 0x8f, 0xdc, 0x28, 0x26, 0x14, 0x2d, 0x43, 0xa1, 0xe7, 0x7b, 0x24, 0xa0, 0x15,
	0x65, 0x55, 0x59, 0xcb, 0x63, 0xc9, 0x21, 0x04, 0x6a, 0x2f, 0x0c, 0x82, 0x4a, 0x96, 0x4b, 0x39,
	0xcd, 0x6c, 0x63, 0x12, 0x9d, 0x92, 0xa8, 0x92, 0x13, 0xb6, 0x82, 0x33, 0x7e, 0xcf, 0xc1, 0x7c,
	0x83, 0xe7, 0x61, 0x47, 0x6e, 0x10, 0xbb, 0x3d, 0xea, 0x85, 0x01, 0xda, 0x02, 0x88, 0xa9, 0x4b,
	0xc9, 0x80, 0x04, 0x34, 0xae, 0x28, 0xab, 0xb9, 0x35, 0xad, 0x7e, 0xa3, 0x36, 0x51, 0xc1, 0x4b,
	0x2e, 0xb5, 0xdd, 0xc4, 0x1e, 0x4f, 0xb8, 0xa2, 0x3a, 0x68, 0xe4, 0x94, 0x04, 0xd4, 0xa1, 0xe1,
	0x31, 0x09, 0x2a, 0xea, 0xaa, 0xb2, 0xa6, 0xd5, 0xe7, 0x6b, 0xa2, 0x40, 0x93, 0x69, 0x6c, 0xa6,
	0xc0, 0x40, 0x52, 0x7a, 0xe5, 0xd7, 0x2c, 0x94, 0xd3, 0x68, 0xc8, 0x82, 0x52, 0xcf, 0xa5, 0xe4,
	0x30, 0x8c, 0x46, 0xbc, 0xcc, 0xd9, 0xfa, 0xcd, 0x2b, 0x26, 0x52, 0x6b, 0x4a, 0x3f, 0x9c, 0x46,
	0x40, 0xef, 0x41, 0xb1, 0x27, 0xd0, 0xe3, 0xe8, 0x68, 0xf5, 0x85, 0xc9, 0x60, 0x12, 0x58, 0x9c,
	0xd8, 0x20, 0x1d, 0x72, 0xf1, 0x13, 0x9f, 0x43, 0x36, 0x83, 0x19, 0x69, 0xfc, 0xa8, 0x40, 0x29,
	0x89, 0x8b, 0x16, 0x60, 0xae, 0x61, 0x39, 0x0f, 0x3b, 0xd8, 0x6c, 0x76, 0xb7, 0x3a, 0xed, 0xc7,
	0x66, 0x4b, 0xcf, 0xa0, 0x19, 0x28, 0x35, 0x2c, 0xa7, 0x61, 0x6e, 0xb5, 0x3b, 0xba, 0x82, 0xae,
	0x41, 0xb9, 0x61, 0x39, 0xcd, 0xee, 0xf6, 0x76, 0xdb, 0xd6, 0xb3, 0x68, 0x0e, 0xb4, 0x86, 0xe5,
	0xe0, 0xae, 0x65, 0x35, 0x36, 0x9b, 0xf7, 0xf5, 0x1c, 0x5a, 0x82, 0xf9, 0x86, 0xe5, 0xb4, 0xb6,
	0x2d, 0xa7, 0x65, 0xee, 0x60, 0xb3, 0xb9, 0x69, 0x9b, 0x2d, 0x5d, 0x45, 0x00, 0x05, 0x26, 0x6e,
	0x59, 0x7a, 0x5e, 0xd2, 0xbb, 0xa6, 0xad, 0x17, 0x64, 0xb8, 0x76, 0x67, 0xd7, 0xc4, 0xb6, 0x5e,
	0x94, 0xec, 0xc3, 0x9d, 0xd6, 0xa6, 0x6d, 0xea, 0x25, 0xc9, 0xb6, 0x4c, 0xcb, 0xb4, 0x4d, 0xbd,
	0x7c, 0x4f, 0x2d, 0x65, 0xf5, 0xdc, 0x3d, 0xb5, 0x94, 0xd3, 0x55, 0xe3, 0x5b, 0x05, 0x96, 0x76,
	0x69, 0x44, 0xdc, 0xc1, 0x7d, 0x32, 0xc2, 0x6e, 0x70, 0x48, 0x30, 0x79, 0x72, 0x42, 0x62, 0x8a,
	0x56, 0xa0, 0x34, 0x0c, 0x63, 0x8f, 0x61, 0xc7, 0x01, 0x2e, 0xe3, 0x94, 0x47, 0x1b, 0x50, 0x3e,
	0x26, 0x23, 0x27, 0x62, 0xf6, 0x12, 0x30, 0x54, 0x4b, 0x07, 0x32, 0x8d, 0x54, 0x3a, 0x96, 0xd4,
	0x24, 0xbe, 0xb9, 0x37, 0xe3, 0x6b, 0x1c, 0xc0, 0xf2, 0xe5, 0xa4, 0xe2, 0x61, 0x18, 0xc4, 0x04,
	0x59, 0x80, 0x84, 0xa3, 0x43, 0xc7, 0xbd, 0xe5, 0xf9, 0x69, 0xf5, 0xeb, 0xaf, 0x1d, 0x00, 0x3c,
	0xbf, 0x7f, 0x59, 0x64, 0x7c, 0x01, 0x0b, 0xe2, 0x1d, 0xdb, 0xdd, 0xf7, 0x49, 0x7c, 0x95, 0xd2,
	0x97, 0xa1, 0x40, 0xb9, 0x71, 0x25, 0xbb, 0x9a, 0x5b, 0x2b, 0x63, 0xc9, 0xfd, 0xdd, 0x0a, 0xfb,
	0xb0, 0x38, 0xfd, 0xf2, 0xbf, 0x52, 0xdf, 0x87, 0xa0, 0xe2, 0x13, 0x9f, 0xa0, 0x45, 0xc8, 0x0f,
	0x5c, 0xda, 0x3b, 0x92, 0xd5, 0x08, 0x86, 0x95, 0x72, 0xe0, 0xf9, 0x94, 0x44, 0xbc, 0x85, 0x65,
	0x2c, 0x39, 0xe3, 0x26, 0x14, 0xee, 0x70, 0x0a, 0xbd, 0x0b, 0xf9, 0xe8, 0x84, 0xd5, 0x2a, 0x7e,
	0xea, 0xfa, 0x64, 0x02, 0x2c, 0x30, 0x16, 0x6a, 0xe3, 0xbb, 0x2c, 0xcc, 0x88, 0x84, 0x76, 0xc3,
	0x93, 0xa8, 0x47, 0x18, 0x82, 0xc7, 0x64, 0x14, 0x0f, 0xdd, 0x1e, 0x49, 0x10, 0x4c, 0x78, 0x96,
	0x4c, 0x7c, 0xe4, 0x46, 0x7d, 0xf9, 0xaa, 0x60, 0xd0, 0x47, 0xa0, 0x71, 0x24, 0xa9, 0x43, 0x47,
	0x43, 0xc2, 0x31, 0x9c, 0xad, 0x2f, 0x8e, 0x87, 0x8a, 0xe3, 0x44, 0xed, 0xd1, 0x90, 0x60, 0xa0,
	0x29, 0x3d, 0x3d, 0x89, 0xea, 0x15, 0x26, 0x71, 0xdc, 0xbf, 0xfc, 0x54, 0xff, 0xd6, 0x53, 0x30,
	0x0a, 0x32, 0xca, 0x44, 0xad, 0x02, 0x8e, 0x04, 0x20, 0x54, 0x83, 0x42, 0x18, 0x38, 0xfd, 0xbe,
	0x5f, 0x29, 0xf2, 0x34, 0xff, 0x37, 0x69, 0xdb, 0x0d, 0x5a, 0x2d, 0x6b, 0x53, 0xb4, 0x24, 0x1f,
	0x06, 0xad, 0xbe, 0x6f, 0x3c, 0x80, 0x32, 0x0e, 0xcf, 0x9a, 0x47, 0x3c, 0x01, 0x03, 0x0a, 0xfb,
	0xe4, 0x20, 0x8c, 0x88, 0xec, 0x2a, 0xc8, 0xad, 0x87, 0xc3, 0x33, 0x2c, 0x35, 0x68, 0x15, 0xf2,
	0xee, 0x41, 0xd2, 0x98, 0x69, 0x13, 0xa1, 0x30, 0x5c, 0x28, 0xe1, 0xf0, 0x8c, 0x6f, 0x4a, 0x74,
	0x1d, 0x04, 0x22, 0x4e, 0xe0, 0x0e, 0x12, 0xb8, 0xcb, 0x5c, 0xd2, 0x71, 0x07, 0x04, 0xdd, 0x02,
	0x2d, 0x0a, 0xcf, 0x9c, 0x1e, 0x7f, 0x5e, 0x8c, 0xad, 0x56, 0x5f, 0x9a, 0x6a, 0x65, 0x92, 0x1c,
	0x86, 0x28, 0x21, 0x63, 0xe3, 0x01, 0xc0, 0x1d, 0x8f, 0xf8, 0xfd, 0x2b, 0x3d, 0xf2, 0x36, 0x83,
	0x8f, 0xf8, 0xfd, 0x24, 0xfe, 0x8c, 0x4c, 0x99, 0x47, 0xc0, 0x52, 0xc7, 0x80, 0xd8, 0x65, 0xdd,
	0xde, 0xa2, 0x5e, 0xff, 0x1f, 0xcc, 0x08, 0x02, 0xf5, 0x90, 0x7a, 0x7d, 0x3e, 0x1c, 0x65, 0xcc,
	0x69, 0xe3, 0x36, 0xe4, 0xf7, 0x78, 0xb8, 0x5b, 0xa0, 0x71, 0x2b, 0x87, 0x89, 0x93, 0x89, 0x9d,
	0x2a, 0x33, 0x7d, 0x1a, 0x43, 0x9c, 0x90, 0xb1, 0xf1, 0x53, 0x16, 0x0a, 0x7b, 0xa2, 0xc6, 0x75,
	0x50, 0xf9, 0xf0, 0x89, 0xef, 0xc9, 0xf2, 0xa4, 0xaf, 0xb0, 0xe0, 0xe3, 0xc7, 0x6d, 0xd0, 0xff,
	0xa1, 0x4c, 0xbd, 0x01, 0x89, 0xa9, 0x3b, 0x18, 0xf2, 0x2c, 0x73, 0x78, 0x2c, 0x78, 0x55, 0xa6,
	0xec, 0xa3, 0xc1, 0x46, 0x46, 0xe5, 0x22, 0x46, 0xa2, 0xf7, 0xa1, 0xcc, 0x3a, 0xc3, 0xbf, 0x71,
	0x95, 0x3c, 0x6f, 0xf5, 0xe2, 0xa5, 0xbe, 0xf0, 0x67, 0x71, 0x29, 0x4a, 0x7a, 0xfd, 0x31, 0x68,
	0x1c, 0x4b, 0xe9, 0x24, 0x66, 0x75, 0x79, 0x7a, 0x56, 0x93, 0x9e, 0x61, 0x38, 0x18, 0xf7, 0xef,
	0x06, 0xe4, 0x4f, 0x79, 0x4a, 0x45, 0xf9, 0xad, 0x9d, 0x2c, 0x8e, 0x83, 0x22, 0xf4, 0xe8, 0x2d,
	0x98, 0xe9, 0x9d, 0x44, 0x11, 0xff, 0x38, 0x7b, 0x03, 0x52, 0x59, 0xe4, 0xb5, 0x69, 0x52, 0x66,
	0x7b, 0x03, 0x62, 0x7c, 0x9d, 0x85, 0xd9, 0x3d, 0xb1, 0xbe, 0x92, 0x95, 0x79, 0x1b, 0x16, 0xc8,
	0xc1, 0x01, 0xe9, 0x51, 0xef, 0x94, 0x38, 0x3d, 0xd7, 0xf7, 0x49, 0xe4, 0x78, 0x7d, 0x39, 0xe2,
	0x73, 0x35, 0x71, 0xc6, 0x34, 0xb9, 0xbc, 0xdd, 0xc2, 0xf3, 0xa9, 0xad, 0x14, 0xf5, 0x91, 0x09,
	0x0b, 0xde, 0x60, 0x40, 0xfa, 0x9e, 0x4b, 0x27, 0x03, 0x88, 0x1f, 0xc0, 0x92, 0x9c, 0xa6, 0x3d,
	0x7b, 0xcb, 0xa5, 0x64, 0x1c, 0x26, 0xf5, 0x48, 0xc3, 0xbc, 0xc3, 0x7e, 0xde, 0xd1, 0x61, 0xba,
	0x85, 0xaf, 0x49, 0x4f, 0x9b, 0x0b, 0xb1, 0x54, 0x4e, 0x6d, 0x78, 0xf5, 0xd2, 0x86, 0x1f, 0x6f,
	0x82, 0xfc, 0x9b, 0x36, 0x81, 0xf1, 0x09, 0xcc, 0xa5, 0x40, 0xc8, 0x0d, 0xbe, 0x0e, 0x05, 0xde,
	0x9b, 0x64, 0x04, 0xd1, 0xcb, 0x63, 0x84, 0xa5, 0x85, 0xf1, 0x55, 0x16, 0x50, 0xe2, 0x1f, 0x9e,
	0xc5, 0xff, 0x51, 0x30, 0x17, 0x21, 0xcf, 0xe5, 0x12, 0x49, 0xc1, 0x30, 0x1c, 0x7c, 0x37, 0xa6,
	0xc3, 0xe3, 0x14, 0x46, 0xe1, 0xfc, 0x80, 0xfd, 0xc5, 0x24, 0x3e, 0xf1, 0x29, 0x96, 0x16, 0xc6,
	0xcf, 0x0a, 0x2c, 0x4c, 0xe1, 0x20, 0xb1, 0x1c, 0x6f, 0x15, 0xe5, 0xaf, 0xb7, 0x0a, 0x5a, 0x83,
	0xd2, 0xf0, 0xf8, 0x35, 0xdb, 0x27, 0xd5, 0xbe, 0xf2, 0x67, 0x59, 0x05, 0x35, 0x0a, 0xcf, 0xe2,
	0x8a, 0xca, 0x3d, 0x27, 0x57, 0x2d, 0x97, 0xb3, 0x7d, 0x3d, 0x55, 0xc7, 0xd4, 0xbe, 0x16, 0x9a,
	0xf5, 0x4f, 0x41, 0x9b, 0x58, 0xfb, 0xec, 0x32, 0x6b, 0x6f, 0x75, 0xba, 0xd8, 0xd4, 0x33, 0xa8,
	0x04, 0xea, 0xae, 0xdd, 0xdd, 0xd1, 0x15, 0x46, 0x99, 0x9f, 0x99, 0x4d, 0x71, 0xed, 0x31, 0xca,
	0x91, 0x46, 0xb9, 0xf5, 0x5f, 0x14, 0x80, 0xf1, 0x86, 0x41, 0x1a, 0x14, 0x1f, 0x76, 0xee, 0x77,
	0xba, 0x8f, 0x3a, 0x22, 0xc0, 0x96, 0xdd, 0x6e, 0xe9, 0x0a, 0x2a, 0x43, 0x5e, 0x9c, 0x8f, 0x59,
	0xf6, 0x82, 0xbc, 0x1d, 0x73, 0xec, 0xb0, 0x4c, 0x0f, 0x47, 0x15, 0x15, 0x21, 0x97, 0x9e, 0x87,
	0xf2, 0x1e, 0x2c, 0xb0, 0x80, 0xd8, 0xdc, 0xb1, 0x36, 0x9b, 0xa6, 0x5e, 0x64, 0x8a, 0xf4, 0x32,
	0x04, 0x28, 0x24, 0x67, 0x21, 0xf3, 0x64, 0xc7, 0x24, 0xb0, 0x77, 0xba, 0xf6, 0x5d, 0x13, 0xeb,
	0x1a, 0x93, 0xe1, 0xee, 0x23, 0x7d, 0x86, 0xc9, 0xee, 0xb4, 0x4d, 0xab, 0xa5, 0x5f, 0x63, 0xd7,
	0xe4, 0x5d, 0x73, 0x13, 0xdb, 0x0d, 0x73, 0xd3, 0xd6, 0x67, 0x99, 0x66, 0x8f, 0x27, 0x38, 0xd7,
	0xf8, 0xfc, 0xe9, 0xf3, 0x6a, 0xe6, 0xd9, 0xf3, 0x6a, 0xe6, 0xc5, 0xf3, 0xaa, 0xf2, 0xe5, 0x79,
	0x55, 0xf9, 0xe1, 0xbc, 0xaa, 0xfc, 0x76, 0x5e, 0x55, 0x9e, 0x9e, 0x57, 0x95, 0x3f, 0xce, 0xab,
	0x99, 0x17, 0xe7, 0x55, 0xe5, 0x9b, 0x8b, 0x6a, 0xe6, 0xfb, 0x8b, 0xaa, 0xf2, 0xf4, 0xa2, 0x9a,
	0x79, 0x76, 0x51, 0xcd, 0x3c, 0xbe, 0x71, 0xea, 0x51, 0x12, 0xc7, 0x35, 0x2f, 0xdc, 0x10, 0xd4,
	0xc6, 0x61, 0xb8, 0x71, 0x4a, 0x37, 0xf8, 0xff, 0x35, 0x1b, 0xe3, 0x1f, 0xcf, 0x7e, 0x81, 0x4b,
	0x3e, 0xf8, 0x33, 0x00, 0x00, 0xff, 0xff, 0x3e, 0xa4, 0x10, 0x79, 0x33, 0x0d, 0x00, 0x00,
}

func (x OnDDLAction) String() string {
	s, ok := OnDDLAction_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x VEventType) String() string {
	s, ok := VEventType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x BinlogTransaction_Statement_Category) String() string {
	s, ok := BinlogTransaction_Statement_Category_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *Charset) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Charset)
	if !ok {
		that2, ok := that.(Charset)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Client != that1.Client {
		return false
	}
	if this.Conn != that1.Conn {
		return false
	}
	if this.Server != that1.Server {
		return false
	}
	return true
}
func (this *BinlogTransaction) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*BinlogTransaction)
	if !ok {
		that2, ok := that.(BinlogTransaction)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Statements) != len(that1.Statements) {
		return false
	}
	for i := range this.Statements {
		if !this.Statements[i].Equal(that1.Statements[i]) {
			return false
		}
	}
	if !this.EventToken.Equal(that1.EventToken) {
		return false
	}
	return true
}
func (this *BinlogTransaction_Statement) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*BinlogTransaction_Statement)
	if !ok {
		that2, ok := that.(BinlogTransaction_Statement)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Category != that1.Category {
		return false
	}
	if !this.Charset.Equal(that1.Charset) {
		return false
	}
	if !bytes.Equal(this.Sql, that1.Sql) {
		return false
	}
	return true
}
func (this *StreamKeyRangeRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StreamKeyRangeRequest)
	if !ok {
		that2, ok := that.(StreamKeyRangeRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Position != that1.Position {
		return false
	}
	if !this.KeyRange.Equal(that1.KeyRange) {
		return false
	}
	if !this.Charset.Equal(that1.Charset) {
		return false
	}
	return true
}
func (this *StreamKeyRangeResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StreamKeyRangeResponse)
	if !ok {
		that2, ok := that.(StreamKeyRangeResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.BinlogTransaction.Equal(that1.BinlogTransaction) {
		return false
	}
	return true
}
func (this *StreamTablesRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StreamTablesRequest)
	if !ok {
		that2, ok := that.(StreamTablesRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Position != that1.Position {
		return false
	}
	if len(this.Tables) != len(that1.Tables) {
		return false
	}
	for i := range this.Tables {
		if this.Tables[i] != that1.Tables[i] {
			return false
		}
	}
	if !this.Charset.Equal(that1.Charset) {
		return false
	}
	return true
}
func (this *StreamTablesResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StreamTablesResponse)
	if !ok {
		that2, ok := that.(StreamTablesResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.BinlogTransaction.Equal(that1.BinlogTransaction) {
		return false
	}
	return true
}
func (this *Rule) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Rule)
	if !ok {
		that2, ok := that.(Rule)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Match != that1.Match {
		return false
	}
	if this.Filter != that1.Filter {
		return false
	}
	return true
}
func (this *Filter) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Filter)
	if !ok {
		that2, ok := that.(Filter)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Rules) != len(that1.Rules) {
		return false
	}
	for i := range this.Rules {
		if !this.Rules[i].Equal(that1.Rules[i]) {
			return false
		}
	}
	return true
}
func (this *BinlogSource) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*BinlogSource)
	if !ok {
		that2, ok := that.(BinlogSource)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Keyspace != that1.Keyspace {
		return false
	}
	if this.Shard != that1.Shard {
		return false
	}
	if this.TabletType != that1.TabletType {
		return false
	}
	if !this.KeyRange.Equal(that1.KeyRange) {
		return false
	}
	if len(this.Tables) != len(that1.Tables) {
		return false
	}
	for i := range this.Tables {
		if this.Tables[i] != that1.Tables[i] {
			return false
		}
	}
	if !this.Filter.Equal(that1.Filter) {
		return false
	}
	if this.OnDdl != that1.OnDdl {
		return false
	}
	return true
}
func (this *RowChange) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RowChange)
	if !ok {
		that2, ok := that.(RowChange)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Before.Equal(that1.Before) {
		return false
	}
	if !this.After.Equal(that1.After) {
		return false
	}
	return true
}
func (this *RowEvent) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RowEvent)
	if !ok {
		that2, ok := that.(RowEvent)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableName != that1.TableName {
		return false
	}
	if len(this.RowChanges) != len(that1.RowChanges) {
		return false
	}
	for i := range this.RowChanges {
		if !this.RowChanges[i].Equal(that1.RowChanges[i]) {
			return false
		}
	}
	return true
}
func (this *FieldEvent) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FieldEvent)
	if !ok {
		that2, ok := that.(FieldEvent)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TableName != that1.TableName {
		return false
	}
	if len(this.Fields) != len(that1.Fields) {
		return false
	}
	for i := range this.Fields {
		if !this.Fields[i].Equal(that1.Fields[i]) {
			return false
		}
	}
	return true
}
func (this *ShardGtid) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ShardGtid)
	if !ok {
		that2, ok := that.(ShardGtid)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Keyspace != that1.Keyspace {
		return false
	}
	if this.Shard != that1.Shard {
		return false
	}
	if this.Gtid != that1.Gtid {
		return false
	}
	return true
}
func (this *VGtid) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VGtid)
	if !ok {
		that2, ok := that.(VGtid)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.ShardGtids) != len(that1.ShardGtids) {
		return false
	}
	for i := range this.ShardGtids {
		if !this.ShardGtids[i].Equal(that1.ShardGtids[i]) {
			return false
		}
	}
	return true
}
func (this *VEvent) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VEvent)
	if !ok {
		that2, ok := that.(VEvent)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if this.Timestamp != that1.Timestamp {
		return false
	}
	if this.Gtid != that1.Gtid {
		return false
	}
	if this.Ddl != that1.Ddl {
		return false
	}
	if !this.RowEvent.Equal(that1.RowEvent) {
		return false
	}
	if !this.FieldEvent.Equal(that1.FieldEvent) {
		return false
	}
	if !this.Vgtid.Equal(that1.Vgtid) {
		return false
	}
	if this.CurrentTime != that1.CurrentTime {
		return false
	}
	return true
}
func (this *VStreamRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VStreamRequest)
	if !ok {
		that2, ok := that.(VStreamRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.EffectiveCallerId.Equal(that1.EffectiveCallerId) {
		return false
	}
	if !this.ImmediateCallerId.Equal(that1.ImmediateCallerId) {
		return false
	}
	if !this.Target.Equal(that1.Target) {
		return false
	}
	if this.Position != that1.Position {
		return false
	}
	if !this.Filter.Equal(that1.Filter) {
		return false
	}
	return true
}
func (this *VStreamResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VStreamResponse)
	if !ok {
		that2, ok := that.(VStreamResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Events) != len(that1.Events) {
		return false
	}
	for i := range this.Events {
		if !this.Events[i].Equal(that1.Events[i]) {
			return false
		}
	}
	return true
}
func (this *VStreamRowsRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VStreamRowsRequest)
	if !ok {
		that2, ok := that.(VStreamRowsRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.EffectiveCallerId.Equal(that1.EffectiveCallerId) {
		return false
	}
	if !this.ImmediateCallerId.Equal(that1.ImmediateCallerId) {
		return false
	}
	if !this.Target.Equal(that1.Target) {
		return false
	}
	if this.Query != that1.Query {
		return false
	}
	if !this.Lastpk.Equal(that1.Lastpk) {
		return false
	}
	return true
}
func (this *VStreamRowsResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VStreamRowsResponse)
	if !ok {
		that2, ok := that.(VStreamRowsResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Fields) != len(that1.Fields) {
		return false
	}
	for i := range this.Fields {
		if !this.Fields[i].Equal(that1.Fields[i]) {
			return false
		}
	}
	if len(this.Pkfields) != len(that1.Pkfields) {
		return false
	}
	for i := range this.Pkfields {
		if !this.Pkfields[i].Equal(that1.Pkfields[i]) {
			return false
		}
	}
	if this.Gtid != that1.Gtid {
		return false
	}
	if len(this.Rows) != len(that1.Rows) {
		return false
	}
	for i := range this.Rows {
		if !this.Rows[i].Equal(that1.Rows[i]) {
			return false
		}
	}
	if !this.Lastpk.Equal(that1.Lastpk) {
		return false
	}
	return true
}
func (this *Charset) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&binlogdata.Charset{")
	s = append(s, "Client: "+fmt.Sprintf("%#v", this.Client)+",\n")
	s = append(s, "Conn: "+fmt.Sprintf("%#v", this.Conn)+",\n")
	s = append(s, "Server: "+fmt.Sprintf("%#v", this.Server)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *BinlogTransaction) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&binlogdata.BinlogTransaction{")
	if this.Statements != nil {
		s = append(s, "Statements: "+fmt.Sprintf("%#v", this.Statements)+",\n")
	}
	if this.EventToken != nil {
		s = append(s, "EventToken: "+fmt.Sprintf("%#v", this.EventToken)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *BinlogTransaction_Statement) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&binlogdata.BinlogTransaction_Statement{")
	s = append(s, "Category: "+fmt.Sprintf("%#v", this.Category)+",\n")
	if this.Charset != nil {
		s = append(s, "Charset: "+fmt.Sprintf("%#v", this.Charset)+",\n")
	}
	s = append(s, "Sql: "+fmt.Sprintf("%#v", this.Sql)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *StreamKeyRangeRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&binlogdata.StreamKeyRangeRequest{")
	s = append(s, "Position: "+fmt.Sprintf("%#v", this.Position)+",\n")
	if this.KeyRange != nil {
		s = append(s, "KeyRange: "+fmt.Sprintf("%#v", this.KeyRange)+",\n")
	}
	if this.Charset != nil {
		s = append(s, "Charset: "+fmt.Sprintf("%#v", this.Charset)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *StreamKeyRangeResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&binlogdata.StreamKeyRangeResponse{")
	if this.BinlogTransaction != nil {
		s = append(s, "BinlogTransaction: "+fmt.Sprintf("%#v", this.BinlogTransaction)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *StreamTablesRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&binlogdata.StreamTablesRequest{")
	s = append(s, "Position: "+fmt.Sprintf("%#v", this.Position)+",\n")
	s = append(s, "Tables: "+fmt.Sprintf("%#v", this.Tables)+",\n")
	if this.Charset != nil {
		s = append(s, "Charset: "+fmt.Sprintf("%#v", this.Charset)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *StreamTablesResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&binlogdata.StreamTablesResponse{")
	if this.BinlogTransaction != nil {
		s = append(s, "BinlogTransaction: "+fmt.Sprintf("%#v", this.BinlogTransaction)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Rule) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&binlogdata.Rule{")
	s = append(s, "Match: "+fmt.Sprintf("%#v", this.Match)+",\n")
	s = append(s, "Filter: "+fmt.Sprintf("%#v", this.Filter)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Filter) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&binlogdata.Filter{")
	if this.Rules != nil {
		s = append(s, "Rules: "+fmt.Sprintf("%#v", this.Rules)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *BinlogSource) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&binlogdata.BinlogSource{")
	s = append(s, "Keyspace: "+fmt.Sprintf("%#v", this.Keyspace)+",\n")
	s = append(s, "Shard: "+fmt.Sprintf("%#v", this.Shard)+",\n")
	s = append(s, "TabletType: "+fmt.Sprintf("%#v", this.TabletType)+",\n")
	if this.KeyRange != nil {
		s = append(s, "KeyRange: "+fmt.Sprintf("%#v", this.KeyRange)+",\n")
	}
	s = append(s, "Tables: "+fmt.Sprintf("%#v", this.Tables)+",\n")
	if this.Filter != nil {
		s = append(s, "Filter: "+fmt.Sprintf("%#v", this.Filter)+",\n")
	}
	s = append(s, "OnDdl: "+fmt.Sprintf("%#v", this.OnDdl)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RowChange) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&binlogdata.RowChange{")
	if this.Before != nil {
		s = append(s, "Before: "+fmt.Sprintf("%#v", this.Before)+",\n")
	}
	if this.After != nil {
		s = append(s, "After: "+fmt.Sprintf("%#v", this.After)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RowEvent) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&binlogdata.RowEvent{")
	s = append(s, "TableName: "+fmt.Sprintf("%#v", this.TableName)+",\n")
	if this.RowChanges != nil {
		s = append(s, "RowChanges: "+fmt.Sprintf("%#v", this.RowChanges)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *FieldEvent) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&binlogdata.FieldEvent{")
	s = append(s, "TableName: "+fmt.Sprintf("%#v", this.TableName)+",\n")
	if this.Fields != nil {
		s = append(s, "Fields: "+fmt.Sprintf("%#v", this.Fields)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ShardGtid) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&binlogdata.ShardGtid{")
	s = append(s, "Keyspace: "+fmt.Sprintf("%#v", this.Keyspace)+",\n")
	s = append(s, "Shard: "+fmt.Sprintf("%#v", this.Shard)+",\n")
	s = append(s, "Gtid: "+fmt.Sprintf("%#v", this.Gtid)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *VGtid) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&binlogdata.VGtid{")
	if this.ShardGtids != nil {
		s = append(s, "ShardGtids: "+fmt.Sprintf("%#v", this.ShardGtids)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *VEvent) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&binlogdata.VEvent{")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	s = append(s, "Timestamp: "+fmt.Sprintf("%#v", this.Timestamp)+",\n")
	s = append(s, "Gtid: "+fmt.Sprintf("%#v", this.Gtid)+",\n")
	s = append(s, "Ddl: "+fmt.Sprintf("%#v", this.Ddl)+",\n")
	if this.RowEvent != nil {
		s = append(s, "RowEvent: "+fmt.Sprintf("%#v", this.RowEvent)+",\n")
	}
	if this.FieldEvent != nil {
		s = append(s, "FieldEvent: "+fmt.Sprintf("%#v", this.FieldEvent)+",\n")
	}
	if this.Vgtid != nil {
		s = append(s, "Vgtid: "+fmt.Sprintf("%#v", this.Vgtid)+",\n")
	}
	s = append(s, "CurrentTime: "+fmt.Sprintf("%#v", this.CurrentTime)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *VStreamRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&binlogdata.VStreamRequest{")
	if this.EffectiveCallerId != nil {
		s = append(s, "EffectiveCallerId: "+fmt.Sprintf("%#v", this.EffectiveCallerId)+",\n")
	}
	if this.ImmediateCallerId != nil {
		s = append(s, "ImmediateCallerId: "+fmt.Sprintf("%#v", this.ImmediateCallerId)+",\n")
	}
	if this.Target != nil {
		s = append(s, "Target: "+fmt.Sprintf("%#v", this.Target)+",\n")
	}
	s = append(s, "Position: "+fmt.Sprintf("%#v", this.Position)+",\n")
	if this.Filter != nil {
		s = append(s, "Filter: "+fmt.Sprintf("%#v", this.Filter)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *VStreamResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&binlogdata.VStreamResponse{")
	if this.Events != nil {
		s = append(s, "Events: "+fmt.Sprintf("%#v", this.Events)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *VStreamRowsRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&binlogdata.VStreamRowsRequest{")
	if this.EffectiveCallerId != nil {
		s = append(s, "EffectiveCallerId: "+fmt.Sprintf("%#v", this.EffectiveCallerId)+",\n")
	}
	if this.ImmediateCallerId != nil {
		s = append(s, "ImmediateCallerId: "+fmt.Sprintf("%#v", this.ImmediateCallerId)+",\n")
	}
	if this.Target != nil {
		s = append(s, "Target: "+fmt.Sprintf("%#v", this.Target)+",\n")
	}
	s = append(s, "Query: "+fmt.Sprintf("%#v", this.Query)+",\n")
	if this.Lastpk != nil {
		s = append(s, "Lastpk: "+fmt.Sprintf("%#v", this.Lastpk)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *VStreamRowsResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&binlogdata.VStreamRowsResponse{")
	if this.Fields != nil {
		s = append(s, "Fields: "+fmt.Sprintf("%#v", this.Fields)+",\n")
	}
	if this.Pkfields != nil {
		s = append(s, "Pkfields: "+fmt.Sprintf("%#v", this.Pkfields)+",\n")
	}
	s = append(s, "Gtid: "+fmt.Sprintf("%#v", this.Gtid)+",\n")
	if this.Rows != nil {
		s = append(s, "Rows: "+fmt.Sprintf("%#v", this.Rows)+",\n")
	}
	if this.Lastpk != nil {
		s = append(s, "Lastpk: "+fmt.Sprintf("%#v", this.Lastpk)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringBinlogdata(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *Charset) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Charset) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Client != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBinlogdata(dAtA, i, uint64(m.Client))
	}
	if m.Conn != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintBinlogdata(dAtA, i, uint64(m.Conn))
	}
	if m.Server != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintBinlogdata(dAtA, i, uint64(m.Server))
	}
	return i, nil
}

func (m *BinlogTransaction) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BinlogTransaction) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Statements) > 0 {
		for _, msg := range m.Statements {
			dAtA[i] = 0xa
			i++
			i = encodeVarintBinlogdata(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.EventToken != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintBinlogdata(dAtA, i, uint64(m.EventToken.ProtoSize()))
		n1, err1 := m.EventToken.MarshalTo(dAtA[i:])
		if err1 != nil {
			return 0, err1
		}
		i += n1
	}
	return i, nil
}

func (m *BinlogTransaction_Statement) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BinlogTransaction_Statement) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Category != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBinlogdata(dAtA, i, uint64(m.Category))
	}
	if m.Charset != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintBinlogdata(dAtA, i, uint64(m.Charset.ProtoSize()))
		n2, err2 := m.Charset.MarshalTo(dAtA[i:])
		if err2 != nil {
			return 0, err2
		}
		i += n2
	}
	if len(m.Sql) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintBinlogdata(dAtA, i, uint64(len(m.Sql)))
		i += copy(dAtA[i:], m.Sql)
	}
	return i, nil
}

func (m *StreamKeyRangeRequest) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StreamKeyRangeRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Position) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBinlogdata(dAtA, i, uint64(len(m.Position)))
		i += copy(dAtA[i:], m.Position)
	}
	if m.KeyRange != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintBinlogdata(dAtA, i, uint64(m.KeyRange.ProtoSize()))
		n3, err3 := m.KeyRange.MarshalTo(dAtA[i:])
		if err3 != nil {
			return 0, err3
		}
		i += n3
	}
	if m.Charset != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintBinlogdata(dAtA, i, uint64(m.Charset.ProtoSize()))
		n4, err4 := m.Charset.MarshalTo(dAtA[i:])
		if err4 != nil {
			return 0, err4
		}
		i += n4
	}
	return i, nil
}

func (m *StreamKeyRangeResponse) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StreamKeyRangeResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BinlogTransaction != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBinlogdata(dAtA, i, uint64(m.BinlogTransaction.ProtoSize()))
		n5, err5 := m.BinlogTransaction.MarshalTo(dAtA[i:])
		if err5 != nil {
			return 0, err5
		}
		i += n5
	}
	return i, nil
}

func (m *StreamTablesRequest) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StreamTablesRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Position) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBinlogdata(dAtA, i, uint64(len(m.Position)))
		i += copy(dAtA[i:], m.Position)
	}
	if len(m.Tables) > 0 {
		for _, s := range m.Tables {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.Charset != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintBinlogdata(dAtA, i, uint64(m.Charset.ProtoSize()))
		n6, err6 := m.Charset.MarshalTo(dAtA[i:])
		if err6 != nil {
			return 0, err6
		}
		i += n6
	}
	return i, nil
}

func (m *StreamTablesResponse) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StreamTablesResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BinlogTransaction != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBinlogdata(dAtA, i, uint64(m.BinlogTransaction.ProtoSize()))
		n7, err7 := m.BinlogTransaction.MarshalTo(dAtA[i:])
		if err7 != nil {
			return 0, err7
		}
		i += n7
	}
	return i, nil
}

func (m *Rule) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Rule) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Match) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBinlogdata(dAtA, i, uint64(len(m.Match)))
		i += copy(dAtA[i:], m.Match)
	}
	if len(m.Filter) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintBinlogdata(dAtA, i, uint64(len(m.Filter)))
		i += copy(dAtA[i:], m.Filter)
	}
	return i, nil
}

func (m *Filter) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Filter) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Rules) > 0 {
		for _, msg := range m.Rules {
			dAtA[i] = 0xa
			i++
			i = encodeVarintBinlogdata(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *BinlogSource) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BinlogSource) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Keyspace) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBinlogdata(dAtA, i, uint64(len(m.Keyspace)))
		i += copy(dAtA[i:], m.Keyspace)
	}
	if len(m.Shard) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintBinlogdata(dAtA, i, uint64(len(m.Shard)))
		i += copy(dAtA[i:], m.Shard)
	}
	if m.TabletType != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintBinlogdata(dAtA, i, uint64(m.TabletType))
	}
	if m.KeyRange != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintBinlogdata(dAtA, i, uint64(m.KeyRange.ProtoSize()))
		n8, err8 := m.KeyRange.MarshalTo(dAtA[i:])
		if err8 != nil {
			return 0, err8
		}
		i += n8
	}
	if len(m.Tables) > 0 {
		for _, s := range m.Tables {
			dAtA[i] = 0x2a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.Filter != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintBinlogdata(dAtA, i, uint64(m.Filter.ProtoSize()))
		n9, err9 := m.Filter.MarshalTo(dAtA[i:])
		if err9 != nil {
			return 0, err9
		}
		i += n9
	}
	if m.OnDdl != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintBinlogdata(dAtA, i, uint64(m.OnDdl))
	}
	return i, nil
}

func (m *RowChange) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RowChange) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Before != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBinlogdata(dAtA, i, uint64(m.Before.ProtoSize()))
		n10, err10 := m.Before.MarshalTo(dAtA[i:])
		if err10 != nil {
			return 0, err10
		}
		i += n10
	}
	if m.After != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintBinlogdata(dAtA, i, uint64(m.After.ProtoSize()))
		n11, err11 := m.After.MarshalTo(dAtA[i:])
		if err11 != nil {
			return 0, err11
		}
		i += n11
	}
	return i, nil
}

func (m *RowEvent) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RowEvent) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.TableName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBinlogdata(dAtA, i, uint64(len(m.TableName)))
		i += copy(dAtA[i:], m.TableName)
	}
	if len(m.RowChanges) > 0 {
		for _, msg := range m.RowChanges {
			dAtA[i] = 0x12
			i++
			i = encodeVarintBinlogdata(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *FieldEvent) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FieldEvent) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.TableName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBinlogdata(dAtA, i, uint64(len(m.TableName)))
		i += copy(dAtA[i:], m.TableName)
	}
	if len(m.Fields) > 0 {
		for _, msg := range m.Fields {
			dAtA[i] = 0x12
			i++
			i = encodeVarintBinlogdata(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ShardGtid) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShardGtid) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Keyspace) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBinlogdata(dAtA, i, uint64(len(m.Keyspace)))
		i += copy(dAtA[i:], m.Keyspace)
	}
	if len(m.Shard) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintBinlogdata(dAtA, i, uint64(len(m.Shard)))
		i += copy(dAtA[i:], m.Shard)
	}
	if len(m.Gtid) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintBinlogdata(dAtA, i, uint64(len(m.Gtid)))
		i += copy(dAtA[i:], m.Gtid)
	}
	return i, nil
}

func (m *VGtid) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VGtid) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ShardGtids) > 0 {
		for _, msg := range m.ShardGtids {
			dAtA[i] = 0xa
			i++
			i = encodeVarintBinlogdata(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *VEvent) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VEvent) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBinlogdata(dAtA, i, uint64(m.Type))
	}
	if m.Timestamp != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintBinlogdata(dAtA, i, uint64(m.Timestamp))
	}
	if len(m.Gtid) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintBinlogdata(dAtA, i, uint64(len(m.Gtid)))
		i += copy(dAtA[i:], m.Gtid)
	}
	if len(m.Ddl) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintBinlogdata(dAtA, i, uint64(len(m.Ddl)))
		i += copy(dAtA[i:], m.Ddl)
	}
	if m.RowEvent != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintBinlogdata(dAtA, i, uint64(m.RowEvent.ProtoSize()))
		n12, err12 := m.RowEvent.MarshalTo(dAtA[i:])
		if err12 != nil {
			return 0, err12
		}
		i += n12
	}
	if m.FieldEvent != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintBinlogdata(dAtA, i, uint64(m.FieldEvent.ProtoSize()))
		n13, err13 := m.FieldEvent.MarshalTo(dAtA[i:])
		if err13 != nil {
			return 0, err13
		}
		i += n13
	}
	if m.Vgtid != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintBinlogdata(dAtA, i, uint64(m.Vgtid.ProtoSize()))
		n14, err14 := m.Vgtid.MarshalTo(dAtA[i:])
		if err14 != nil {
			return 0, err14
		}
		i += n14
	}
	if m.CurrentTime != 0 {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintBinlogdata(dAtA, i, uint64(m.CurrentTime))
	}
	return i, nil
}

func (m *VStreamRequest) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VStreamRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.EffectiveCallerId != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBinlogdata(dAtA, i, uint64(m.EffectiveCallerId.ProtoSize()))
		n15, err15 := m.EffectiveCallerId.MarshalTo(dAtA[i:])
		if err15 != nil {
			return 0, err15
		}
		i += n15
	}
	if m.ImmediateCallerId != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintBinlogdata(dAtA, i, uint64(m.ImmediateCallerId.ProtoSize()))
		n16, err16 := m.ImmediateCallerId.MarshalTo(dAtA[i:])
		if err16 != nil {
			return 0, err16
		}
		i += n16
	}
	if m.Target != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintBinlogdata(dAtA, i, uint64(m.Target.ProtoSize()))
		n17, err17 := m.Target.MarshalTo(dAtA[i:])
		if err17 != nil {
			return 0, err17
		}
		i += n17
	}
	if len(m.Position) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintBinlogdata(dAtA, i, uint64(len(m.Position)))
		i += copy(dAtA[i:], m.Position)
	}
	if m.Filter != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintBinlogdata(dAtA, i, uint64(m.Filter.ProtoSize()))
		n18, err18 := m.Filter.MarshalTo(dAtA[i:])
		if err18 != nil {
			return 0, err18
		}
		i += n18
	}
	return i, nil
}

func (m *VStreamResponse) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VStreamResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Events) > 0 {
		for _, msg := range m.Events {
			dAtA[i] = 0xa
			i++
			i = encodeVarintBinlogdata(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *VStreamRowsRequest) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VStreamRowsRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.EffectiveCallerId != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBinlogdata(dAtA, i, uint64(m.EffectiveCallerId.ProtoSize()))
		n19, err19 := m.EffectiveCallerId.MarshalTo(dAtA[i:])
		if err19 != nil {
			return 0, err19
		}
		i += n19
	}
	if m.ImmediateCallerId != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintBinlogdata(dAtA, i, uint64(m.ImmediateCallerId.ProtoSize()))
		n20, err20 := m.ImmediateCallerId.MarshalTo(dAtA[i:])
		if err20 != nil {
			return 0, err20
		}
		i += n20
	}
	if m.Target != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintBinlogdata(dAtA, i, uint64(m.Target.ProtoSize()))
		n21, err21 := m.Target.MarshalTo(dAtA[i:])
		if err21 != nil {
			return 0, err21
		}
		i += n21
	}
	if len(m.Query) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintBinlogdata(dAtA, i, uint64(len(m.Query)))
		i += copy(dAtA[i:], m.Query)
	}
	if m.Lastpk != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintBinlogdata(dAtA, i, uint64(m.Lastpk.ProtoSize()))
		n22, err22 := m.Lastpk.MarshalTo(dAtA[i:])
		if err22 != nil {
			return 0, err22
		}
		i += n22
	}
	return i, nil
}

func (m *VStreamRowsResponse) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VStreamRowsResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Fields) > 0 {
		for _, msg := range m.Fields {
			dAtA[i] = 0xa
			i++
			i = encodeVarintBinlogdata(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Pkfields) > 0 {
		for _, msg := range m.Pkfields {
			dAtA[i] = 0x12
			i++
			i = encodeVarintBinlogdata(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Gtid) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintBinlogdata(dAtA, i, uint64(len(m.Gtid)))
		i += copy(dAtA[i:], m.Gtid)
	}
	if len(m.Rows) > 0 {
		for _, msg := range m.Rows {
			dAtA[i] = 0x22
			i++
			i = encodeVarintBinlogdata(dAtA, i, uint64(msg.ProtoSize()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Lastpk != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintBinlogdata(dAtA, i, uint64(m.Lastpk.ProtoSize()))
		n23, err23 := m.Lastpk.MarshalTo(dAtA[i:])
		if err23 != nil {
			return 0, err23
		}
		i += n23
	}
	return i, nil
}

func encodeVarintBinlogdata(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Charset) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Client != 0 {
		n += 1 + sovBinlogdata(uint64(m.Client))
	}
	if m.Conn != 0 {
		n += 1 + sovBinlogdata(uint64(m.Conn))
	}
	if m.Server != 0 {
		n += 1 + sovBinlogdata(uint64(m.Server))
	}
	return n
}

func (m *BinlogTransaction) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Statements) > 0 {
		for _, e := range m.Statements {
			l = e.ProtoSize()
			n += 1 + l + sovBinlogdata(uint64(l))
		}
	}
	if m.EventToken != nil {
		l = m.EventToken.ProtoSize()
		n += 1 + l + sovBinlogdata(uint64(l))
	}
	return n
}

func (m *BinlogTransaction_Statement) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Category != 0 {
		n += 1 + sovBinlogdata(uint64(m.Category))
	}
	if m.Charset != nil {
		l = m.Charset.ProtoSize()
		n += 1 + l + sovBinlogdata(uint64(l))
	}
	l = len(m.Sql)
	if l > 0 {
		n += 1 + l + sovBinlogdata(uint64(l))
	}
	return n
}

func (m *StreamKeyRangeRequest) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Position)
	if l > 0 {
		n += 1 + l + sovBinlogdata(uint64(l))
	}
	if m.KeyRange != nil {
		l = m.KeyRange.ProtoSize()
		n += 1 + l + sovBinlogdata(uint64(l))
	}
	if m.Charset != nil {
		l = m.Charset.ProtoSize()
		n += 1 + l + sovBinlogdata(uint64(l))
	}
	return n
}

func (m *StreamKeyRangeResponse) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BinlogTransaction != nil {
		l = m.BinlogTransaction.ProtoSize()
		n += 1 + l + sovBinlogdata(uint64(l))
	}
	return n
}

func (m *StreamTablesRequest) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Position)
	if l > 0 {
		n += 1 + l + sovBinlogdata(uint64(l))
	}
	if len(m.Tables) > 0 {
		for _, s := range m.Tables {
			l = len(s)
			n += 1 + l + sovBinlogdata(uint64(l))
		}
	}
	if m.Charset != nil {
		l = m.Charset.ProtoSize()
		n += 1 + l + sovBinlogdata(uint64(l))
	}
	return n
}

func (m *StreamTablesResponse) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BinlogTransaction != nil {
		l = m.BinlogTransaction.ProtoSize()
		n += 1 + l + sovBinlogdata(uint64(l))
	}
	return n
}

func (m *Rule) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Match)
	if l > 0 {
		n += 1 + l + sovBinlogdata(uint64(l))
	}
	l = len(m.Filter)
	if l > 0 {
		n += 1 + l + sovBinlogdata(uint64(l))
	}
	return n
}

func (m *Filter) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Rules) > 0 {
		for _, e := range m.Rules {
			l = e.ProtoSize()
			n += 1 + l + sovBinlogdata(uint64(l))
		}
	}
	return n
}

func (m *BinlogSource) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Keyspace)
	if l > 0 {
		n += 1 + l + sovBinlogdata(uint64(l))
	}
	l = len(m.Shard)
	if l > 0 {
		n += 1 + l + sovBinlogdata(uint64(l))
	}
	if m.TabletType != 0 {
		n += 1 + sovBinlogdata(uint64(m.TabletType))
	}
	if m.KeyRange != nil {
		l = m.KeyRange.ProtoSize()
		n += 1 + l + sovBinlogdata(uint64(l))
	}
	if len(m.Tables) > 0 {
		for _, s := range m.Tables {
			l = len(s)
			n += 1 + l + sovBinlogdata(uint64(l))
		}
	}
	if m.Filter != nil {
		l = m.Filter.ProtoSize()
		n += 1 + l + sovBinlogdata(uint64(l))
	}
	if m.OnDdl != 0 {
		n += 1 + sovBinlogdata(uint64(m.OnDdl))
	}
	return n
}

func (m *RowChange) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Before != nil {
		l = m.Before.ProtoSize()
		n += 1 + l + sovBinlogdata(uint64(l))
	}
	if m.After != nil {
		l = m.After.ProtoSize()
		n += 1 + l + sovBinlogdata(uint64(l))
	}
	return n
}

func (m *RowEvent) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TableName)
	if l > 0 {
		n += 1 + l + sovBinlogdata(uint64(l))
	}
	if len(m.RowChanges) > 0 {
		for _, e := range m.RowChanges {
			l = e.ProtoSize()
			n += 1 + l + sovBinlogdata(uint64(l))
		}
	}
	return n
}

func (m *FieldEvent) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TableName)
	if l > 0 {
		n += 1 + l + sovBinlogdata(uint64(l))
	}
	if len(m.Fields) > 0 {
		for _, e := range m.Fields {
			l = e.ProtoSize()
			n += 1 + l + sovBinlogdata(uint64(l))
		}
	}
	return n
}

func (m *ShardGtid) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Keyspace)
	if l > 0 {
		n += 1 + l + sovBinlogdata(uint64(l))
	}
	l = len(m.Shard)
	if l > 0 {
		n += 1 + l + sovBinlogdata(uint64(l))
	}
	l = len(m.Gtid)
	if l > 0 {
		n += 1 + l + sovBinlogdata(uint64(l))
	}
	return n
}

func (m *VGtid) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ShardGtids) > 0 {
		for _, e := range m.ShardGtids {
			l = e.ProtoSize()
			n += 1 + l + sovBinlogdata(uint64(l))
		}
	}
	return n
}

func (m *VEvent) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovBinlogdata(uint64(m.Type))
	}
	if m.Timestamp != 0 {
		n += 1 + sovBinlogdata(uint64(m.Timestamp))
	}
	l = len(m.Gtid)
	if l > 0 {
		n += 1 + l + sovBinlogdata(uint64(l))
	}
	l = len(m.Ddl)
	if l > 0 {
		n += 1 + l + sovBinlogdata(uint64(l))
	}
	if m.RowEvent != nil {
		l = m.RowEvent.ProtoSize()
		n += 1 + l + sovBinlogdata(uint64(l))
	}
	if m.FieldEvent != nil {
		l = m.FieldEvent.ProtoSize()
		n += 1 + l + sovBinlogdata(uint64(l))
	}
	if m.Vgtid != nil {
		l = m.Vgtid.ProtoSize()
		n += 1 + l + sovBinlogdata(uint64(l))
	}
	if m.CurrentTime != 0 {
		n += 2 + sovBinlogdata(uint64(m.CurrentTime))
	}
	return n
}

func (m *VStreamRequest) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EffectiveCallerId != nil {
		l = m.EffectiveCallerId.ProtoSize()
		n += 1 + l + sovBinlogdata(uint64(l))
	}
	if m.ImmediateCallerId != nil {
		l = m.ImmediateCallerId.ProtoSize()
		n += 1 + l + sovBinlogdata(uint64(l))
	}
	if m.Target != nil {
		l = m.Target.ProtoSize()
		n += 1 + l + sovBinlogdata(uint64(l))
	}
	l = len(m.Position)
	if l > 0 {
		n += 1 + l + sovBinlogdata(uint64(l))
	}
	if m.Filter != nil {
		l = m.Filter.ProtoSize()
		n += 1 + l + sovBinlogdata(uint64(l))
	}
	return n
}

func (m *VStreamResponse) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Events) > 0 {
		for _, e := range m.Events {
			l = e.ProtoSize()
			n += 1 + l + sovBinlogdata(uint64(l))
		}
	}
	return n
}

func (m *VStreamRowsRequest) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EffectiveCallerId != nil {
		l = m.EffectiveCallerId.ProtoSize()
		n += 1 + l + sovBinlogdata(uint64(l))
	}
	if m.ImmediateCallerId != nil {
		l = m.ImmediateCallerId.ProtoSize()
		n += 1 + l + sovBinlogdata(uint64(l))
	}
	if m.Target != nil {
		l = m.Target.ProtoSize()
		n += 1 + l + sovBinlogdata(uint64(l))
	}
	l = len(m.Query)
	if l > 0 {
		n += 1 + l + sovBinlogdata(uint64(l))
	}
	if m.Lastpk != nil {
		l = m.Lastpk.ProtoSize()
		n += 1 + l + sovBinlogdata(uint64(l))
	}
	return n
}

func (m *VStreamRowsResponse) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Fields) > 0 {
		for _, e := range m.Fields {
			l = e.ProtoSize()
			n += 1 + l + sovBinlogdata(uint64(l))
		}
	}
	if len(m.Pkfields) > 0 {
		for _, e := range m.Pkfields {
			l = e.ProtoSize()
			n += 1 + l + sovBinlogdata(uint64(l))
		}
	}
	l = len(m.Gtid)
	if l > 0 {
		n += 1 + l + sovBinlogdata(uint64(l))
	}
	if len(m.Rows) > 0 {
		for _, e := range m.Rows {
			l = e.ProtoSize()
			n += 1 + l + sovBinlogdata(uint64(l))
		}
	}
	if m.Lastpk != nil {
		l = m.Lastpk.ProtoSize()
		n += 1 + l + sovBinlogdata(uint64(l))
	}
	return n
}

func sovBinlogdata(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozBinlogdata(x uint64) (n int) {
	return sovBinlogdata(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *Charset) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Charset{`,
		`Client:` + fmt.Sprintf("%v", this.Client) + `,`,
		`Conn:` + fmt.Sprintf("%v", this.Conn) + `,`,
		`Server:` + fmt.Sprintf("%v", this.Server) + `,`,
		`}`,
	}, "")
	return s
}
func (this *BinlogTransaction) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForStatements := "[]*BinlogTransaction_Statement{"
	for _, f := range this.Statements {
		repeatedStringForStatements += strings.Replace(fmt.Sprintf("%v", f), "BinlogTransaction_Statement", "BinlogTransaction_Statement", 1) + ","
	}
	repeatedStringForStatements += "}"
	s := strings.Join([]string{`&BinlogTransaction{`,
		`Statements:` + repeatedStringForStatements + `,`,
		`EventToken:` + strings.Replace(fmt.Sprintf("%v", this.EventToken), "EventToken", "query.EventToken", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *BinlogTransaction_Statement) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&BinlogTransaction_Statement{`,
		`Category:` + fmt.Sprintf("%v", this.Category) + `,`,
		`Charset:` + strings.Replace(this.Charset.String(), "Charset", "Charset", 1) + `,`,
		`Sql:` + fmt.Sprintf("%v", this.Sql) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StreamKeyRangeRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StreamKeyRangeRequest{`,
		`Position:` + fmt.Sprintf("%v", this.Position) + `,`,
		`KeyRange:` + strings.Replace(fmt.Sprintf("%v", this.KeyRange), "KeyRange", "topodata.KeyRange", 1) + `,`,
		`Charset:` + strings.Replace(this.Charset.String(), "Charset", "Charset", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StreamKeyRangeResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StreamKeyRangeResponse{`,
		`BinlogTransaction:` + strings.Replace(this.BinlogTransaction.String(), "BinlogTransaction", "BinlogTransaction", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StreamTablesRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StreamTablesRequest{`,
		`Position:` + fmt.Sprintf("%v", this.Position) + `,`,
		`Tables:` + fmt.Sprintf("%v", this.Tables) + `,`,
		`Charset:` + strings.Replace(this.Charset.String(), "Charset", "Charset", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *StreamTablesResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&StreamTablesResponse{`,
		`BinlogTransaction:` + strings.Replace(this.BinlogTransaction.String(), "BinlogTransaction", "BinlogTransaction", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Rule) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Rule{`,
		`Match:` + fmt.Sprintf("%v", this.Match) + `,`,
		`Filter:` + fmt.Sprintf("%v", this.Filter) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Filter) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForRules := "[]*Rule{"
	for _, f := range this.Rules {
		repeatedStringForRules += strings.Replace(f.String(), "Rule", "Rule", 1) + ","
	}
	repeatedStringForRules += "}"
	s := strings.Join([]string{`&Filter{`,
		`Rules:` + repeatedStringForRules + `,`,
		`}`,
	}, "")
	return s
}
func (this *BinlogSource) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&BinlogSource{`,
		`Keyspace:` + fmt.Sprintf("%v", this.Keyspace) + `,`,
		`Shard:` + fmt.Sprintf("%v", this.Shard) + `,`,
		`TabletType:` + fmt.Sprintf("%v", this.TabletType) + `,`,
		`KeyRange:` + strings.Replace(fmt.Sprintf("%v", this.KeyRange), "KeyRange", "topodata.KeyRange", 1) + `,`,
		`Tables:` + fmt.Sprintf("%v", this.Tables) + `,`,
		`Filter:` + strings.Replace(this.Filter.String(), "Filter", "Filter", 1) + `,`,
		`OnDdl:` + fmt.Sprintf("%v", this.OnDdl) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RowChange) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RowChange{`,
		`Before:` + strings.Replace(fmt.Sprintf("%v", this.Before), "Row", "query.Row", 1) + `,`,
		`After:` + strings.Replace(fmt.Sprintf("%v", this.After), "Row", "query.Row", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RowEvent) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForRowChanges := "[]*RowChange{"
	for _, f := range this.RowChanges {
		repeatedStringForRowChanges += strings.Replace(f.String(), "RowChange", "RowChange", 1) + ","
	}
	repeatedStringForRowChanges += "}"
	s := strings.Join([]string{`&RowEvent{`,
		`TableName:` + fmt.Sprintf("%v", this.TableName) + `,`,
		`RowChanges:` + repeatedStringForRowChanges + `,`,
		`}`,
	}, "")
	return s
}
func (this *FieldEvent) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForFields := "[]*Field{"
	for _, f := range this.Fields {
		repeatedStringForFields += strings.Replace(fmt.Sprintf("%v", f), "Field", "query.Field", 1) + ","
	}
	repeatedStringForFields += "}"
	s := strings.Join([]string{`&FieldEvent{`,
		`TableName:` + fmt.Sprintf("%v", this.TableName) + `,`,
		`Fields:` + repeatedStringForFields + `,`,
		`}`,
	}, "")
	return s
}
func (this *ShardGtid) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ShardGtid{`,
		`Keyspace:` + fmt.Sprintf("%v", this.Keyspace) + `,`,
		`Shard:` + fmt.Sprintf("%v", this.Shard) + `,`,
		`Gtid:` + fmt.Sprintf("%v", this.Gtid) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VGtid) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForShardGtids := "[]*ShardGtid{"
	for _, f := range this.ShardGtids {
		repeatedStringForShardGtids += strings.Replace(f.String(), "ShardGtid", "ShardGtid", 1) + ","
	}
	repeatedStringForShardGtids += "}"
	s := strings.Join([]string{`&VGtid{`,
		`ShardGtids:` + repeatedStringForShardGtids + `,`,
		`}`,
	}, "")
	return s
}
func (this *VEvent) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VEvent{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Timestamp:` + fmt.Sprintf("%v", this.Timestamp) + `,`,
		`Gtid:` + fmt.Sprintf("%v", this.Gtid) + `,`,
		`Ddl:` + fmt.Sprintf("%v", this.Ddl) + `,`,
		`RowEvent:` + strings.Replace(this.RowEvent.String(), "RowEvent", "RowEvent", 1) + `,`,
		`FieldEvent:` + strings.Replace(this.FieldEvent.String(), "FieldEvent", "FieldEvent", 1) + `,`,
		`Vgtid:` + strings.Replace(this.Vgtid.String(), "VGtid", "VGtid", 1) + `,`,
		`CurrentTime:` + fmt.Sprintf("%v", this.CurrentTime) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VStreamRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VStreamRequest{`,
		`EffectiveCallerId:` + strings.Replace(fmt.Sprintf("%v", this.EffectiveCallerId), "CallerID", "vtrpc.CallerID", 1) + `,`,
		`ImmediateCallerId:` + strings.Replace(fmt.Sprintf("%v", this.ImmediateCallerId), "VTGateCallerID", "query.VTGateCallerID", 1) + `,`,
		`Target:` + strings.Replace(fmt.Sprintf("%v", this.Target), "Target", "query.Target", 1) + `,`,
		`Position:` + fmt.Sprintf("%v", this.Position) + `,`,
		`Filter:` + strings.Replace(this.Filter.String(), "Filter", "Filter", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VStreamResponse) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForEvents := "[]*VEvent{"
	for _, f := range this.Events {
		repeatedStringForEvents += strings.Replace(f.String(), "VEvent", "VEvent", 1) + ","
	}
	repeatedStringForEvents += "}"
	s := strings.Join([]string{`&VStreamResponse{`,
		`Events:` + repeatedStringForEvents + `,`,
		`}`,
	}, "")
	return s
}
func (this *VStreamRowsRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VStreamRowsRequest{`,
		`EffectiveCallerId:` + strings.Replace(fmt.Sprintf("%v", this.EffectiveCallerId), "CallerID", "vtrpc.CallerID", 1) + `,`,
		`ImmediateCallerId:` + strings.Replace(fmt.Sprintf("%v", this.ImmediateCallerId), "VTGateCallerID", "query.VTGateCallerID", 1) + `,`,
		`Target:` + strings.Replace(fmt.Sprintf("%v", this.Target), "Target", "query.Target", 1) + `,`,
		`Query:` + fmt.Sprintf("%v", this.Query) + `,`,
		`Lastpk:` + strings.Replace(fmt.Sprintf("%v", this.Lastpk), "QueryResult", "query.QueryResult", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VStreamRowsResponse) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForFields := "[]*Field{"
	for _, f := range this.Fields {
		repeatedStringForFields += strings.Replace(fmt.Sprintf("%v", f), "Field", "query.Field", 1) + ","
	}
	repeatedStringForFields += "}"
	repeatedStringForPkfields := "[]*Field{"
	for _, f := range this.Pkfields {
		repeatedStringForPkfields += strings.Replace(fmt.Sprintf("%v", f), "Field", "query.Field", 1) + ","
	}
	repeatedStringForPkfields += "}"
	repeatedStringForRows := "[]*Row{"
	for _, f := range this.Rows {
		repeatedStringForRows += strings.Replace(fmt.Sprintf("%v", f), "Row", "query.Row", 1) + ","
	}
	repeatedStringForRows += "}"
	s := strings.Join([]string{`&VStreamRowsResponse{`,
		`Fields:` + repeatedStringForFields + `,`,
		`Pkfields:` + repeatedStringForPkfields + `,`,
		`Gtid:` + fmt.Sprintf("%v", this.Gtid) + `,`,
		`Rows:` + repeatedStringForRows + `,`,
		`Lastpk:` + strings.Replace(fmt.Sprintf("%v", this.Lastpk), "Row", "query.Row", 1) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringBinlogdata(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *Charset) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBinlogdata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Charset: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Charset: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Client", wireType)
			}
			m.Client = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Client |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conn", wireType)
			}
			m.Conn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Conn |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Server", wireType)
			}
			m.Server = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Server |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBinlogdata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BinlogTransaction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBinlogdata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BinlogTransaction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BinlogTransaction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Statements", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBinlogdata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Statements = append(m.Statements, &BinlogTransaction_Statement{})
			if err := m.Statements[len(m.Statements)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventToken", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBinlogdata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EventToken == nil {
				m.EventToken = &query.EventToken{}
			}
			if err := m.EventToken.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBinlogdata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BinlogTransaction_Statement) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBinlogdata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Statement: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Statement: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Category", wireType)
			}
			m.Category = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Category |= BinlogTransaction_Statement_Category(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Charset", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBinlogdata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Charset == nil {
				m.Charset = &Charset{}
			}
			if err := m.Charset.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sql", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBinlogdata
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sql = append(m.Sql[:0], dAtA[iNdEx:postIndex]...)
			if m.Sql == nil {
				m.Sql = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBinlogdata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StreamKeyRangeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBinlogdata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StreamKeyRangeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StreamKeyRangeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Position", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBinlogdata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Position = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBinlogdata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyRange == nil {
				m.KeyRange = &topodata.KeyRange{}
			}
			if err := m.KeyRange.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Charset", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBinlogdata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Charset == nil {
				m.Charset = &Charset{}
			}
			if err := m.Charset.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBinlogdata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StreamKeyRangeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBinlogdata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StreamKeyRangeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StreamKeyRangeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BinlogTransaction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBinlogdata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BinlogTransaction == nil {
				m.BinlogTransaction = &BinlogTransaction{}
			}
			if err := m.BinlogTransaction.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBinlogdata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StreamTablesRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBinlogdata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StreamTablesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StreamTablesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Position", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBinlogdata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Position = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tables", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBinlogdata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tables = append(m.Tables, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Charset", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBinlogdata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Charset == nil {
				m.Charset = &Charset{}
			}
			if err := m.Charset.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBinlogdata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StreamTablesResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBinlogdata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StreamTablesResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StreamTablesResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BinlogTransaction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBinlogdata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BinlogTransaction == nil {
				m.BinlogTransaction = &BinlogTransaction{}
			}
			if err := m.BinlogTransaction.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBinlogdata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Rule) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBinlogdata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Rule: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Rule: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Match", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBinlogdata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Match = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBinlogdata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Filter = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBinlogdata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Filter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBinlogdata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Filter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Filter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBinlogdata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rules = append(m.Rules, &Rule{})
			if err := m.Rules[len(m.Rules)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBinlogdata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BinlogSource) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBinlogdata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BinlogSource: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BinlogSource: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keyspace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBinlogdata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keyspace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shard", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBinlogdata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Shard = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TabletType", wireType)
			}
			m.TabletType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TabletType |= topodata.TabletType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBinlogdata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyRange == nil {
				m.KeyRange = &topodata.KeyRange{}
			}
			if err := m.KeyRange.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tables", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBinlogdata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tables = append(m.Tables, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBinlogdata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Filter == nil {
				m.Filter = &Filter{}
			}
			if err := m.Filter.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnDdl", wireType)
			}
			m.OnDdl = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OnDdl |= OnDDLAction(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBinlogdata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RowChange) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBinlogdata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RowChange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RowChange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Before", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBinlogdata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Before == nil {
				m.Before = &query.Row{}
			}
			if err := m.Before.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field After", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBinlogdata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.After == nil {
				m.After = &query.Row{}
			}
			if err := m.After.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBinlogdata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RowEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBinlogdata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RowEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RowEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBinlogdata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TableName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RowChanges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBinlogdata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RowChanges = append(m.RowChanges, &RowChange{})
			if err := m.RowChanges[len(m.RowChanges)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBinlogdata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FieldEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBinlogdata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FieldEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FieldEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBinlogdata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TableName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fields", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBinlogdata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fields = append(m.Fields, &query.Field{})
			if err := m.Fields[len(m.Fields)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBinlogdata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShardGtid) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBinlogdata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShardGtid: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShardGtid: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keyspace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBinlogdata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keyspace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shard", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBinlogdata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Shard = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gtid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBinlogdata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Gtid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBinlogdata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VGtid) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBinlogdata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VGtid: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VGtid: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardGtids", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBinlogdata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ShardGtids = append(m.ShardGtids, &ShardGtid{})
			if err := m.ShardGtids[len(m.ShardGtids)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBinlogdata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBinlogdata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= VEventType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gtid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBinlogdata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Gtid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ddl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBinlogdata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ddl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RowEvent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBinlogdata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RowEvent == nil {
				m.RowEvent = &RowEvent{}
			}
			if err := m.RowEvent.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FieldEvent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBinlogdata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FieldEvent == nil {
				m.FieldEvent = &FieldEvent{}
			}
			if err := m.FieldEvent.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vgtid", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBinlogdata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Vgtid == nil {
				m.Vgtid = &VGtid{}
			}
			if err := m.Vgtid.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentTime", wireType)
			}
			m.CurrentTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurrentTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBinlogdata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VStreamRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBinlogdata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VStreamRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VStreamRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EffectiveCallerId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBinlogdata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EffectiveCallerId == nil {
				m.EffectiveCallerId = &vtrpc.CallerID{}
			}
			if err := m.EffectiveCallerId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImmediateCallerId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBinlogdata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ImmediateCallerId == nil {
				m.ImmediateCallerId = &query.VTGateCallerID{}
			}
			if err := m.ImmediateCallerId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBinlogdata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Target == nil {
				m.Target = &query.Target{}
			}
			if err := m.Target.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Position", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBinlogdata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Position = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBinlogdata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Filter == nil {
				m.Filter = &Filter{}
			}
			if err := m.Filter.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBinlogdata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VStreamResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBinlogdata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VStreamResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VStreamResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Events", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBinlogdata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Events = append(m.Events, &VEvent{})
			if err := m.Events[len(m.Events)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBinlogdata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VStreamRowsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBinlogdata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VStreamRowsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VStreamRowsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EffectiveCallerId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBinlogdata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EffectiveCallerId == nil {
				m.EffectiveCallerId = &vtrpc.CallerID{}
			}
			if err := m.EffectiveCallerId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImmediateCallerId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBinlogdata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ImmediateCallerId == nil {
				m.ImmediateCallerId = &query.VTGateCallerID{}
			}
			if err := m.ImmediateCallerId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBinlogdata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Target == nil {
				m.Target = &query.Target{}
			}
			if err := m.Target.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBinlogdata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Query = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lastpk", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBinlogdata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Lastpk == nil {
				m.Lastpk = &query.QueryResult{}
			}
			if err := m.Lastpk.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBinlogdata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VStreamRowsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBinlogdata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VStreamRowsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VStreamRowsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fields", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBinlogdata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fields = append(m.Fields, &query.Field{})
			if err := m.Fields[len(m.Fields)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pkfields", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBinlogdata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pkfields = append(m.Pkfields, &query.Field{})
			if err := m.Pkfields[len(m.Pkfields)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gtid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBinlogdata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Gtid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rows", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBinlogdata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rows = append(m.Rows, &query.Row{})
			if err := m.Rows[len(m.Rows)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lastpk", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBinlogdata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Lastpk == nil {
				m.Lastpk = &query.Row{}
			}
			if err := m.Lastpk.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBinlogdata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBinlogdata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipBinlogdata(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowBinlogdata
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBinlogdata
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthBinlogdata
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthBinlogdata
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowBinlogdata
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipBinlogdata(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthBinlogdata
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthBinlogdata = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowBinlogdata   = fmt.Errorf("proto: integer overflow")
)
